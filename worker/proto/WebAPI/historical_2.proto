// Historical related messages

syntax = "proto2";

package historical_2;

import "WebAPI/market_data_2.proto";
import "common/decimal.proto";
import "common/shared_1.proto";

// Parameters for Time and Sales request.
message TimeAndSalesParameters
{
  // Contract ID for Time and Sales request.
  //
  // Source: metadata_2.ContractMetadata.contract_id.
  required uint32 contract_id = 1;

  // Level of requested Time and Sales data.
  enum Level
  {
    // Get trades with volumes and settlement quotes.
    LEVEL_TRADES = 1;

    // Get trades, settlement and best ask & bid quotes with volumes.
    LEVEL_TRADES_BBA_VOLUMES = 3;
  }

  // Source: TimeAndSalesParameters.Level.
  required uint32 level = 2;

  // Time and Sales period time to start from.
  required sint64 from_utc_time = 3;

  // Optional Time and Sales period finish time.
  //
  // Note: Latest allowed and available time is used if it is not specified.
  optional sint64 to_utc_time = 4;

  // Includes Off Market trade quotes in report.
  optional bool include_off_market_trades = 5;

  // Quotes from report include trade attributes.
  optional bool include_trade_attributes = 6;
}

// Historical data request of time and sales.
//
// Prerequisites: client must have permission to time and sales data.
//
// Limits:
//
// 1. The number of simultaneous historical requests in processing is 10 by default
//    (including all types of historical requests).
// 2. The number of simultaneous historical requests with a subscription for updates is 50 by default
//    (including all types of historical requests).
// 3. 30-day history limit by default.
//
// Responses: TimeAndSalesReport.
message TimeAndSalesRequest
{
  // Request ID.
  //
  // Note: Should be unique among currently processed requests.
  required uint32 request_id = 1;

  // Parameters of a request, ignored for a REQUEST_TYPE_DROP operation.
  optional TimeAndSalesParameters time_and_sales_parameters = 2;

  // Type of request.
  enum RequestType
  {
    // Request data.
    REQUEST_TYPE_GET = 1;

    // Drop request before server completes it.
    REQUEST_TYPE_DROP = 3;
  }

  // Note: REQUEST_TYPE_GET operation is processed by default.
  //
  // Source: TimeAndSalesRequest.RequestType.
  optional uint32 request_type = 3;
}

// Time and sales report.
//
// Requests: TimeAndSalesRequest.
message TimeAndSalesReport
{
  // ID of a corresponding request.
  //
  // Source: TimeAndSalesRequest.request_id.
  required uint32 request_id = 1;

  // Result code.
  enum ResultCode
  {
    /// success codes  (0 - 99)

    // Request is processed successfully.
    RESULT_CODE_SUCCESS = 0;

    // The request is dropped by the client.
    RESULT_CODE_DROPPED = 2;

    // Request processing status that indicates that currently processing is impossible because of communication issues.
    //
    // Note: Clients should not resend requests in this case, the server will restore processing with
    // sending RESULT_CODE_SUCCESS status once communication issues are resolved.
    // If the client is not interested in this request any longer it should send REQUEST_TYPE_DROP request.
    RESULT_CODE_DISCONNECTED = 4;

    /// failure codes (100+)

    // General failure.
    RESULT_CODE_FAILURE = 101;

    // The user is not allowed to access this instrument data.
    RESULT_CODE_ACCESS_DENIED = 103;

    // Requested information is not found.
    RESULT_CODE_NOT_FOUND = 104;

    // Requested data is outside of the allowed range.
    RESULT_CODE_OUTSIDE_ALLOWED_RANGE = 105;

    // The limit of the active historical requests has been violated.
    RESULT_CODE_ACTIVE_REQUESTS_LIMIT_VIOLATION = 106;

    // The request rate limit has been violated.
    RESULT_CODE_REQUEST_RATE_LIMIT_VIOLATION = 107;

    // T&S request is not supported for specified contract.
    RESULT_CODE_NOT_SUPPORTED = 110;

    // Parameters of a T&S request are invalid.
    RESULT_CODE_INVALID_PARAMS = 111;
  }

  // Source: TimeAndSalesReport.ResultCode.
  required uint32 result_code = 2;

  // List of the requested Time and Sales as quotes.
  //
  // Note: In order to simplify linking of T&S with real time quotes by a client server will atomically include
  // all quotes with the same time-stamp into T&S without splitting the group.
  repeated market_data_2.Quote quotes = 3;

  // List of corrections.
  repeated market_data_2.Quote corrections = 10;

  // Time up to which the quotes were included in this report.
  //
  // Note: If there were several quotes with the same time-stamp equal to this time then all are included in
  // the report (UTC). This time is set only for 'up-to-current' requests.
  optional int64 up_to_utc_time = 4;

  // Note: True means that requested data is complete at the moment,
  // false means more report messages are expected for completeness.
  optional bool is_report_complete = 5 [default = true];

  // Optional failure details.
  optional string text_message = 6 [deprecated = true];

  // Optional failure details.
  optional shared_1.Text details = 11;

  // Request contains dates partially outside of allowed historical data depth.
  optional bool truncated = 7;

  // Off Market trade quotes are included.
  //
  // Note: Always False if the user didn't request Off Market trades.
  optional bool off_market_trades_included = 8;

  // Trade attributes are included.
  //
  // Note: Always False if user didn't request trade attributes.
  optional bool trade_attributes_included = 9;
}

// Continuation parameters for TimeBarRequest.
message ContinuationParameters
{
  enum ContinuationType
  {
    // Rollover with trading activity (corresponds with ContractMetadata.is_most_active).
    CONTINUATION_TYPE_ACTIVE = 1;

    // Rollover at expiration (non-Delayed and non-EOD contracts only).
    CONTINUATION_TYPE_STANDARD = 2;
  }

  // Source: ContinuationParameters.ContinuationType.
  required uint32 continuation_type = 1;

  // Equalize closes (opens for bonds).
  //
  // Note: Supported for CONTINUATION_TYPE_ACTIVE continuation only.
  optional bool equalize = 2 [default = false];
}

// Bar building tick type enumeration.
enum BarBuildingTickType
{
  // Bid.
  BAR_BUILDING_TICK_TYPE_BID = 1;

  // Ask.
  BAR_BUILDING_TICK_TYPE_ASK = 2;

  // Trade.
  BAR_BUILDING_TICK_TYPE_TRADE = 3;

  // Settlement.
  BAR_BUILDING_TICK_TYPE_SETTLEMENT = 4;
}

// Bar unit type.
//
// Note: when Spread Bars are requested the history limit of Leg Bar Interval is applied.
enum BarUnit
{
  /// Multi-day bars (3 year history limit for non-option contracts, 3 days for options).

  // yearly bars.
  BAR_UNIT_YEAR = 1;

  // semi-annual bars.
  BAR_UNIT_SEMI_ANNUAL = 2;

  // quarterly bars.
  BAR_UNIT_QUARTER = 3;

  // monthly bars.
  BAR_UNIT_MONTH = 4;

  // weekly bars.
  BAR_UNIT_WEEK = 5;

  // daily bars.
  BAR_UNIT_DAY = 6;

  /// Intra-day bars (3 month history limit).

  // hourly bars.
  BAR_UNIT_HOUR = 7;

  // minute bars.
  BAR_UNIT_MIN = 8;
}

// Parameters of a time bar request.
message TimeBarParameters
{
  // Contract ID for a bar request.
  // If the contract is a synthetic strategy, the request provides Spread Bars.
  //
  // Source: metadata_2.ContractMetadata.contract_id.
  required uint32 contract_id = 1;

  // For a spread bar request this field specifies spread bar interval bar unit.
  //
  // Source: BarUnit.
  required uint32 bar_unit = 2;

  // Number of units per a single bar for Intra-day bars (must be within 24 hours period).
  // For a spread bar request this field specifies spread bar interval unit number.
  optional uint32 unit_number = 3;

  // Leg bar unit for a spread bar request (when contract_id represents a Synthetic Strategy).
  // This field is associated with BarUnit enum type.
  // Minimal allowed intervals:
  //
  //  - Month leg bar interval - for Year, Semiannual, and Quarter spread bar interval,
  //  - Day leg bar interval - for Month spread bar interval,
  //  - Hour leg bar interval - for Week spread bar interval,
  //  - 5 min leg bar interval - for Day spread bar interval.
  //  - 1 min leg bar interval - for intra-day spread bar intervals.
  //
  // Default value is the minimal allowed.
  optional uint32 leg_bar_unit = 13;

  // Leg bar unit number for a spread bar request (when contract_id represents a Synthetic Strategy).
  // Number of units per a single bar for Intra-day leg bars (must be within 24 hours period).
  // Default value - see leg_bar_unit.
  optional uint32 leg_unit_number = 14;

  // For inter-commodity spreads, or any spread where the two contracts have different trading hours,
  // the option defines how to handle the pricing when one entity is not trading.
  //
  //  - If true, the spread is calculated using the closing value for each subsequent bar of the later closing commodity
  //    plotted against the closing value of the contract with the earlier close.
  //  - If false, the spread stops updating when the early contract closes, with all the values representing
  //    concurrent prices between the two commodities.
  //
  // Applicable to spread bar requests with intra-day leg bars only.
  // Default value is false.
  optional bool last_bar_spans_to_end_of_all_sessions = 15;

  // Optional bars period time to start from.
  //
  // Note: Either from_utc_time or bar_count must be specified.
  //
  // 1. For daily and multi-day bars represents starting trade date (time part is ignored), inclusive.
  // 2. For intra-day bars represents starting time, inclusive.
  // 3. Start time is automatically aligned to the closest starting time of selected unit.
  //    For example if bar_unit is BAR_UNIT_MONTH and from_utc_time is November 08
  //    bar starting time will be set the first working day of November.
  optional sint64 from_utc_time = 4;

  // Optional number of requested bars.
  //
  // Note: Either from_utc_time or bar_count must be specified.
  // When specified, from_utc_time is calculated based on to_utc_time, bar_count, selected bar_unit and unit_number
  // (for intra-day bars).
  //
  // Note: The maximum number of bars that can be requested in one message is limited, 100000 by default.
  optional uint32 bar_count = 12;

  // Optional bars period finish time.
  //
  // Note: Latest allowed and available time is used if it is not specified.
  //
  // 1. For daily and multi-day bars represents trade date of the last returned bar (time part is ignored), inclusive.
  // 2. For intra-day bars represents finish time, exclusive.
  // 3. Finish time is automatically aligned to the closest finish time of selected unit.
  //    For example if bar_unit is BAR_UNIT_MONTH and to_utc_time is November 08
  //    bar finish time will be set to the last working day of November.
  optional sint64 to_utc_time = 5;

  reserved 6;

  // Note: Use close_sources instead.
  optional uint32 deprecated_close_price_preference = 10 [deprecated = true];

  // List of sources for closing price in bar building.
  //
  // Note: Order of sources defines what is used if several sources are available (from highest to lowest priority).
  // This field is associated with metadata_2.CloseSource enum type.
  // When the list is empty, default close sources are used (ContractMetadata.close_sources).
  // If the list is not empty, it must contain CLOSE_SOURCE_LAST_QUOTE, otherwise the request is rejected.
  // Can be non-empty for requests with bar_unit equal to BAR_UNIT_DAY or greater, otherwise request is rejected.
  repeated uint32 close_sources = 11;

  // Continuation parameters.
  //
  // Request for Spread Bars with continuation uses bars for legs with continuation,
  // so the continuation parameters are adapted for each leg:
  //
  //  - a Future leg takes the continuation type specified,
  //  - a Bond leg takes active continuation if any continuation type is specified,
  //  - bars for other legs are requested without continuation,
  //  - equalization is not supported.
  optional ContinuationParameters continuation_parameters = 7;

  // List of tick types to be used in bar building.
  //
  // Note: When the list is empty, commodity default tick types are used.
  // It can be non-empty for intra-day bar requests only, otherwise the request is rejected.
  // BAR_BUILDING_TICK_TYPE_SETTLEMENT tick type can only be used in combination with other type(s),
  // otherwise request is rejected.
  //
  // Note: not supported for Spread Bar requests.
  //
  // Source: BarBuildingTickType.
  repeated uint32 tick_types = 8;

  // Update interval, in milliseconds, after which bar is reported, if changed.
  //
  // Note: Minimum is 1 second for Intra-day bars and 10 seconds for historical bars.
  // Maximum is 1 hour for both.
  // Maximum update interval for Intra-day bars is also limited by chosen bar_unit and bar_number values
  // (e.g., if bar_unit is MINUTE and bar_number is 10 update interval can't exceed 600 seconds).
  // Default is 1 second for Intra-day bars or 10 seconds for historical bars, if omitted.
  optional uint32 update_interval = 9;
}

// Historical data request for time bars with optional subscription.
//
// Prerequisites: client must have permission to specified bar data.
//
// Note: In the case of subscription, updates are sent when a bar opens, closes or when it is corrected.
// Corrected bars are sent even if they are outside of the requested time bounds.
// Range can be expanded with another request if needed.
//
// If specified contract is a synthetic strategy, the request provides Spread Bars.
// This request is not supported for aggregation strategies.
//
// Limits:
//
// 1. The number of simultaneous historical requests in processing is 10 by default
//    (including all types of historical requests).
// 2. The number of simultaneous historical requests with a subscription for updates is 50 by default
//    (including all types of historical requests).
//
// Responses: TimeBarReport.
message TimeBarRequest
{
  // Request or subscription ID.
  required uint32 request_id = 1;

  // Parameters of a request, ignored for a REQUEST_TYPE_DROP operation.
  optional TimeBarParameters time_bar_parameters = 2;

  // Type of a bar request.
  enum RequestType
  {
    // Request bars without subscription.
    REQUEST_TYPE_GET = 1;

    // Request bars with subscription for updates.
    //
    // Note: To_utc_time parameter must not be specified to subscribe.
    // Subscription requests for deleted instruments (ContractMetadata.deleted=True) are rejected.
    REQUEST_TYPE_SUBSCRIBE = 2;

    // Drop request before server completes it and/or unsubscribe if already subscribed for updates.
    REQUEST_TYPE_DROP = 3;
  }

  // Note: REQUEST_TYPE_GET operation is processed by default.
  //
  // Source: TimeBarRequest.RequestType.
  optional uint32 request_type = 3;
}

// Continuation segment.
message ContinuationSegment
{
  // Short contract symbol in CQG dialect.
  optional string short_contract_symbol = 1;

  // Contract ID.
  //
  // Note: If an unknown ID is received, the contract metadata can be obtained via metadata_2.ContractMetadataRequest.
  //
  // Source: metadata_2.ContractMetadata.contract_id.
  optional uint32 contract_id = 2;

  // Full contract symbol in CQG dialect.
  //
  // Source: metadata_2.ContractMetadata.contract_symbol.
  optional string contract_symbol = 3;

  // Full contract symbol in the dialect.
  //
  // Can be empty string. E.g., if user_session_2.Logon.dialect_id is "0" (which means default, CQG dialect)
  // or no available dialect metadata.
  // Use 'contract_symbol' in this case.
  optional string dialect_contract_symbol = 4;
}

// Time bar.
message TimeBar
{
  // Bar start time (UTC).
  required sint64 bar_utc_time = 1;

  // Open price.
  optional sint64 scaled_open_price = 2;

  // High price.
  optional sint64 scaled_high_price = 3;

  // Low price.
  optional sint64 scaled_low_price = 4;

  // Close or last price (if the bar is not closed yet).
  optional sint64 scaled_close_price = 5;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 6 [deprecated = true];

  // Bar volume.
  optional cqg.Decimal volume = 15;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar in a requested period
  // and for each first bar of the following trade dates for intra-day bars.
  // Trade date of the bar first day for daily and multi-day bars.
  optional sint64 trade_date = 7;

  // Note: Use 'commodity_volume' instead.
  optional uint64 scaled_commodity_volume = 8 [deprecated = true];

  // Commodity volume where available, for daily and multi-day bars only.
  optional cqg.Decimal commodity_volume = 16;

  // Note: Use 'open_interest' instead.
  optional uint64 scaled_open_interest = 9 [deprecated = true];

  // Open interest, for daily and multi-day bars only.
  optional cqg.Decimal open_interest = 17;

  // Note: Use 'commodity_open_interest' instead.
  optional uint64 scaled_commodity_open_interest = 10 [deprecated = true];

  // Commodity open interest, for daily and multi-day bars only.
  optional cqg.Decimal commodity_open_interest = 18;

  // Settlement price, provided for daily bars only.
  // Note: not provided for Spread Bar requests.
  optional sint64 scaled_settlement_price = 11;

  // Exchange close price, provided for daily bars only.
  optional sint64 scaled_exchange_close_price = 19;

  // Tick volume.
  optional uint64 tick_volume = 12;

  // Commodity tick volume where available, for daily and multi-day bars only.
  optional uint64 commodity_tick_volume = 13;

  // Continuation segments the bar belongs to.
  // Used only for continuation bars with BAR_UNIT_MONTH and smaller BarUnit.
  // For an outright contract the field lists only one segment and is set for the first bar
  // and for each first bar from the next continuation segment.
  // For a Synthetic Strategy (a Spread Bar request) the field lists segments
  // of all legs whenever a single leg has contract changed.
  repeated ContinuationSegment continuation_segments = 14;
}

// Bar report status code enumeration.
enum BarReportStatusCode
{
  /// success codes  (0 - 99)

  // Request is processed without subscription (subscription was not requested).
  BAR_REPORT_STATUS_CODE_SUCCESS = 0;

  // Request is processed and subscription is established or restored after disconnection.
  //
  // Note: If the subscription is restored, the following data will be returned to the user:
  //
  // 1. TimeBarRequest-s - all missed bars;
  // 2. NonTimedBarRequest-s - NonTimedBarRequest.bar_range.count last bars.
  BAR_REPORT_STATUS_CODE_SUBSCRIBED = 1;

  // The request or subscription is dropped by the client.
  BAR_REPORT_STATUS_CODE_DROPPED = 2;

  // Unsolicited information update because of subscription.
  BAR_REPORT_STATUS_CODE_UPDATE = 3;

  // Subscription or request processing status that indicates that currently processing is impossible
  // because of communication issues.
  //
  // Note: Clients should not resubscribe or resend requests in this case, the server will restore processing with
  // sending BAR_REPORT_STATUS_CODE_SUCCESS or BAR_REPORT_STATUS_CODE_SUBSCRIBED status
  // once communication issues are resolved.
  // If client is not interested in this request or subscription any longer it should send REQUEST_TYPE_DROP request.
  BAR_REPORT_STATUS_CODE_DISCONNECTED = 4;

  // Bars are invalidated for specified time range due to data correction.
  //
  // Note: Re-request historical bars and/or re-subscribe to bar updates to receive valid bar data.
  // Subscription is not dropped.
  BAR_REPORT_STATUS_CODE_INVALIDATED = 5;

  /// failure codes (100+), subscription (if any) is dropped in this case.

  // General failure.
  BAR_REPORT_STATUS_CODE_FAILURE = 101;

  // The user is not allowed to access this data.
  BAR_REPORT_STATUS_CODE_ACCESS_DENIED = 103;

  // Requested information is not found.
  BAR_REPORT_STATUS_CODE_NOT_FOUND = 104;

  // Requested data is outside of the allowed range.
  BAR_REPORT_STATUS_CODE_OUTSIDE_ALLOWED_RANGE = 105;

  // Parameters of a bar request are invalid.
  BAR_REPORT_STATUS_CODE_INVALID_PARAMS = 106;

  // The limit of active requests has been violated.
  BAR_REPORT_STATUS_CODE_ACTIVE_REQUESTS_LIMIT_VIOLATION = 107;

  // The limit of simultaneous historical subscriptions has been violated.
  BAR_REPORT_STATUS_CODE_SUBSCRIPTION_LIMIT_VIOLATION = 108;

  // The request rate limit has been violated.
  BAR_REPORT_STATUS_CODE_REQUEST_RATE_LIMIT_VIOLATION = 109;

  // Bar request without subscription on updates is not supported for specified contract.
  BAR_REPORT_STATUS_CODE_NOT_SUPPORTED = 110;

  // Requested time bar update interval is outside of the allowed range.
  BAR_REPORT_STATUS_CODE_UPDATE_INTERVAL_OUTSIDE_ALLOWED_RANGE = 111;
}

// Time bar data response or update.
//
// Note: Each report contains a set of bars sorted in descending order by bar_utc_time.
// Reports related to a specific request ordered chronologically from the most recent one to the past.
// Warning: bar updates are not synchronized with real time data so a real-time quote that is included into
// a bar might be received either before or after the bar update,
// use time of a quote for possible real-time bar updates.
//
// Requests: TimeBarRequest.
message TimeBarReport
{
  // ID of a corresponding request or subscription.
  required uint32 request_id = 1;

  // Source: BarReportStatusCode.
  required uint32 status_code = 2;

  // List of time bars.
  repeated TimeBar time_bars = 3;

  // Time up to which the quotes were included into bars,
  //
  // Note: If there were several with the same time-stamp equal to this time then all are included into
  // the last bar (UTC). This time is set for 'up-to-current' bar requests and only if report contains
  // current (incomplete) bar.
  //
  // Note: This field is not provided for subscriptions to Spread Bars.
  optional int64 up_to_utc_time = 4;

  // Note: True means that requested data is complete at the moment,
  // false means more report messages are expected for completeness.
  optional bool is_report_complete = 5 [default = true];

  // Optional failure details.
  optional string text_message = 6 [deprecated = true];

  // Request contains dates partially outside of allowed historical data depth.
  optional bool truncated = 7;

  // Optional failure details.
  optional shared_1.Text details = 8;

  // Note: True means that we reached start of data that we store for this contract. Earlier data is not available.
  // Can be True only for intra-day bar requests, for daily and multi-day bar requests it's not provided.
  optional bool reached_start_of_data = 9;
}

// Range of bars.
message BarRange
{
  // Boundary time of the requested range (see enum TimeDirection for the details).
  optional sint64 utc_time = 1;

  // Number of requested bars.
  //
  // Note: The maximum number of bars that can be requested in one message is limited, 100000 by default.
  required uint32 count = 2;

  // Boundary index of the requested range (see enum TimeDirection for the details).
  optional sint32 index = 3;

  // Time direction.
  enum TimeDirection
  {
    // Note: 'utc_time' and 'index' define the right bound of the requested range.
    // If 'utc_time' is not specified then latest allowed and available time is used.
    // The right bound is exclusive: the report will contain specified count of bars preceding the boundary.
    // Each report will contain a set of bars sorted in descending order by (bar_utc_time, index).
    // Reports related to a specific request will be ordered chronologically from the most recent one to the past.
    TIME_DIRECTION_BACKWARD = 1;
  }

  // Note: TIME_DIRECTION_BACKWARD is used by default.
  //
  // Source: BarRange.TimeDirection.
  optional uint32 time_direction = 4;
}

// Historical data request for non-time based bars with optional subscription.
//
// Prerequisites: client must have permission to specified bar data.
//
// Limits:
//
// 1. The number of simultaneous historical requests in processing is 10 by default
//    (including all types of historical requests).
// 2. The number of simultaneous historical requests with a subscription for updates is 50 by default
//    (including all types of historical requests).
// 3. 3-month history limit.
//
// Responses: NonTimedBarReport.
message NonTimedBarRequest
{
  // Request ID.
  required uint32 request_id = 1;

  // Type of request action.
  enum RequestType
  {
    // Request bars without subscription.
    REQUEST_TYPE_GET = 1;

    // Request bars with subscription for updates.
    //
    // Note: Utc_time parameter of BarRange must not be specified to subscribe.
    // Subscription requests for deleted instruments (ContractMetadata.deleted=True) are rejected.
    REQUEST_TYPE_SUBSCRIBE = 2;

    // Drop request before server completes it and/or unsubscribe if already subscribed for updates.
    REQUEST_TYPE_DROP = 3;
  }

  // Note: REQUEST_TYPE_GET operation is processed by default.
  //
  // Source: NonTimedBarRequest.RequestType.
  optional uint32 request_type = 2;

  // Continuation parameters.
  optional ContinuationParameters continuation_parameters = 3;

  // Contract ID.
  //
  // Note: Must be specified for REQUEST_TYPE_GET or REQUEST_TYPE_SUBSCRIBE types of request.
  //
  // Source: metadata_2.ContractMetadata.contract_id.
  optional uint32 contract_id = 4;

  // Specifies bar range of a request.
  //
  // Note: Must be specified for REQUEST_TYPE_GET or REQUEST_TYPE_SUBSCRIBE types of request.
  optional BarRange bar_range = 5;

  // List of tick types to be used in bar building.
  //
  // Note: When the list is empty, commodity default tick types are used.
  // Requests with BAR_BUILDING_TICK_TYPE_SETTLEMENT tick type in a list are rejected.
  //
  // Source: BarBuildingTickType.
  repeated uint32 tick_types = 10;

  /// Only one of following optional fields has to be specified.

  // Constant volume bar request parameters.
  optional ConstantVolumeBarParameters constant_volume_bar_parameters = 6;

  // P&F request parameters.
  optional PointAndFigureParameters point_and_figure_parameters = 7;

  // Renko bar request parameters.
  optional RenkoBarParameters renko_bar_parameters = 8;

  // Range bar request parameters.
  optional RangeBarParameters range_bar_parameters = 9;

  // Tick bar request parameters.
  optional TickBarParameters tick_bar_parameters = 11;
}

// Parameters of a Renko bar request.
message RenkoBarParameters
{
  // Size of single brick.
  //
  // Note: Can take a value from 1 to 1000000000.
  required uint32 brick_size = 1;

  // Maximum number of null bricks that can be generated as a single brick in the case of price gaps.
  //
  // Note: Can take a value from 0 to 200. Default value is 0.
  optional uint32 max_null_bricks = 2;

  // Start point values.
  enum StartPoint
  {
    // Renko calculation resets at the beginning of session.
    START_POINT_SESSION = 0;

    // Renko calculation resets at the beginning of week (corresponds to start of weekly timed bar)
    START_POINT_WEEK = 1;

    // Renko calculation resets at the beginning of month (corresponds to start of monthly timed bar).
    START_POINT_MONTH = 2;
  }

  // Note: START_POINT_SESSION is processed by default.
  //
  // Source: RenkoBarParameters.StartPoint.
  optional uint32 start_point = 3;
}

// Parameters of a Range bar request.
message RangeBarParameters
{
  // Size of single range bar.
  //
  // Note: Can take a value from 1 to 1000000000.
  required uint32 range_size = 1;

  reserved 2;

  // Start point values.
  enum StartPoint
  {
    // Range bar calculation resets at the beginning of session.
    START_POINT_SESSION = 0;

    // Range bar calculation resets at the beginning of week.
    START_POINT_WEEK = 1;

    // Range bar calculation resets at the beginning of month.
    START_POINT_MONTH = 2;
  }

  // Note: START_POINT_SESSION is processed by default.
  //
  // Source: RangeBarParameters.StartPoint.
  optional uint32 start_point = 3;
}

// Parameters of a Tick bar request.
message TickBarParameters
{
  // Note: Use 0-plus and 0-minus ticks when building bars.
  optional bool use_flat_ticks = 1;
}

// Non-time based bar data response or update.
//
// Note: Each report contains a set of bars. The order of bars depends on BarRange.time_direction
// specified in the request. The order of reports related to a specific request depends on
// BarRange.time_direction specified in the request.
//
// Requests: NonTimedBarRequest.
message NonTimedBarReport
{
  // ID of the request.
  required uint32 request_id = 1;

  // Source: BarReportStatusCode.
  required uint32 status_code = 2;

  // Optional failure details.
  optional shared_1.Text details = 3;

  // Time from which bars are invalidated.
  optional sint64 invalidated_from_utc_time = 4;

  // Time up to which bars are invalidated.
  //
  // Note: If 'invalidated_from_utc_time' is set and 'invalidated_to_utc_time' isn't set, then bars are invalidated
  // up to current time. In this case, bar updates stopped for this subscription.
  optional sint64 invalidated_to_utc_time = 5;

  // Time up to which the quotes were included into bars,
  //
  // Note: If there were several with the same time-stamp equal to this time
  // then all are included into the report (UTC).
  // This time is set only for requests with unspecified 'utc_time' parameter of message BarRange and only if report
  // contains current (incomplete) bar.
  optional int64 up_to_utc_time = 6;

  // Note: It is set only if the number of requested bars exceeded limit.
  optional bool truncated_by_bar_count = 7;

  // Note: True means that requested data is complete at the moment,
  // false means more report messages are expected for completeness.
  optional bool is_report_complete = 8 [default = true];

  // Note: True means that we reached start of data that we store for this contract. Earlier data is not available.
  optional bool reached_start_of_data = 14;

  /// Only one of the following repeated fields is specified.

  // Constant volume bars.
  repeated ConstantVolumeBar constant_volume_bars = 9;

  // Point and figure bars.
  repeated PointAndFigureBar point_and_figure_bars = 10;

  // Renko bars.
  repeated RenkoBar renko_bars = 11;

  // Range bars.
  repeated RangeBar range_bars = 12;

  // Tick bars.
  repeated TickBar tick_bars = 13;
}

// Parameters of a Constant Volume Bar request.
message ConstantVolumeBarParameters
{
  // Note: Use volume_level instead.
  optional uint32 obsolete_volume_level = 1 [deprecated = true];

  // Volume covered by each bar.
  //
  // Note: Cannot be less than metadata_2.ContractMetadata.trade_size_increment
  // and higher than metadata_2.ContractMetadata.trade_size_increment*1000000000.
  optional cqg.Decimal volume_level = 4;

  // Determines volume type. If false (default value) then bars are built based on exchange volume,
  // otherwise they are built based on ticks (number of inside price changes).
  //
  // Note: If use_tick_volume is true, volume_level is rounded down.
  // WebAPI server rejects requests for contracts without actual volume data
  // (ContractMetadata.has_exchange_volume=False).
  optional bool use_tick_volume = 2;

  // Note: Use 0-plus and 0-minus ticks when building bars.
  // Applicable only to tick volume.
  optional bool use_flat_ticks = 3;
}

// Parameters of a Point and Figure request.
message PointAndFigureParameters
{
  // Specifies the number of tick units represented by each P&F.
  //
  // Note: Can take a value from 1 to 1000.
  required uint32 box_size = 1;

  // Specifies the number of boxes for P&F direction reversal.
  //
  // Note: Can take a value from 1 to 1000.
  required uint32 reversal = 2;
}

// Constant Volume Bar.
message ConstantVolumeBar
{
  // Bar start time (UTC).
  //
  // Note: It is set only for the first bar of the following bar start times.
  optional sint64 bar_utc_time = 1;

  // Bar index.
  //
  // Note: Different bars with the same bar_utc_time always have different indexes.
  // Greater index means later bar.
  // It is set only if non-zero.
  optional sint32 index = 2;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar of the following trade dates.
  optional sint64 trade_date = 3;

  // Open price.
  optional sint64 scaled_open_price = 4;

  // High price.
  optional sint64 scaled_high_price = 5;

  // Low price.
  optional sint64 scaled_low_price = 6;

  // Close or last price (if the bar is not closed yet).
  optional sint64 scaled_close_price = 7;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 8 [deprecated = true];

  // Exchange volume.
  optional cqg.Decimal volume = 11;

  // Tick volume.
  optional uint64 tick_volume = 9;

  // Continuation segment the bar belongs to.
  //
  // Note: It is set only for the first bar and for each first bar from the next continuation segment.
  optional ContinuationSegment continuation_segment = 10;
}

// Point and Figure bar.
message PointAndFigureBar
{
  // Bar start time (UTC).
  //
  // Note: It is set only for the first bar of the following bar start times.
  optional sint64 bar_utc_time = 1;

  // Bar index.
  //
  // Note: Different bars with the same bar_utc_time always have different indexes.
  // Greater index means later bar.
  // It is set only if non-zero.
  optional sint32 index = 2;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar of the following trade dates.
  optional sint64 trade_date = 3;

  // Open price.
  optional sint64 pf_scaled_open_price = 4;

  // High price (rounded to PF box).
  optional sint64 pf_scaled_high_price = 5;

  // Low price (rounded to PF box).
  optional sint64 pf_scaled_low_price = 6;

  // Close price.
  optional sint64 pf_scaled_close_price = 7;

  // High price (not rounded to PF box).
  optional sint64 scaled_high_price = 8;

  // Low price (not rounded to PF box).
  optional sint64 scaled_low_price = 9;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 10 [deprecated = true];

  // Exchange volume.
  optional cqg.Decimal volume = 14;

  // Tick volume.
  optional uint64 tick_volume = 11;

  // Note: True if the P&F chart is plotting an X, False if the P&F chart is plotting an O.
  optional bool up = 12;

  // Continuation segment the bar belongs to.
  //
  // Note: It is set only for the first bar and for each first bar from the next continuation segment.
  optional ContinuationSegment continuation_segment = 13;
}

// Renko bar.
message RenkoBar
{
  // Bar start time (UTC).
  //
  // Note: It is set only for the first bar of the following bar start times.
  optional sint64 bar_utc_time = 1;

  // Bar index.
  //
  // Note: Different bars with the same bar_utc_time always have different indexes.
  // Greater index means later bar.
  // It is set only if non-zero.
  optional sint32 index = 2;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar of the following trade dates.
  optional sint64 trade_date = 3;

  // Open price.
  optional sint64 scaled_open_price = 4;

  // High price.
  optional sint64 scaled_high_price = 5;

  // Low price.
  optional sint64 scaled_low_price = 6;

  // Close or last price (if the bar is not closed yet).
  optional sint64 scaled_close_price = 7;

  // Maximum of open and close prices.
  optional sint64 scaled_renko_high_price = 8;

  // Minimum of open and close prices.
  optional sint64 scaled_renko_low_price = 9;

  // Defines how Renko bar is going to be closed (up or down).
  optional bool up = 10;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 11 [deprecated = true];

  // Exchange volume.
  optional cqg.Decimal volume = 15;

  // Tick volume.
  optional uint64 tick_volume = 12;

  // If this bar is the first bar after start point.
  optional bool first_bar_after_start_point = 13;

  // Continuation segment the bar belongs to.
  //
  // Note: It is set only for the first bar and for each first bar from the next continuation segment.
  optional ContinuationSegment continuation_segment = 14;
}

// Range bar.
message RangeBar
{
  // Bar start time (UTC).
  //
  // Note: It is set only for the first bar of the following bar start times.
  optional sint64 bar_utc_time = 1;

  // Bar index.
  //
  // Note: Different bars with the same bar_utc_time always have different indexes.
  // Greater index means later bar.
  // It is set only if non-zero.
  optional sint32 index = 2;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar of the following trade dates.
  optional sint64 trade_date = 3;

  // Open price.
  optional sint64 scaled_open_price = 4;

  // High price.
  optional sint64 scaled_high_price = 5;

  // Low price.
  optional sint64 scaled_low_price = 6;

  // Close or last price (if the bar is not closed yet).
  optional sint64 scaled_close_price = 7;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 8 [deprecated = true];

  // Exchange volume.
  optional cqg.Decimal volume = 11;

  // Tick volume.
  optional uint64 tick_volume = 9;

  // Continuation segment the bar belongs to.
  //
  // Note: It is set only for the first bar and for each first bar from the next continuation segment.
  optional ContinuationSegment continuation_segment = 10;
}

// Tick bar.
message TickBar
{
  // Bar start time (UTC).
  //
  // Note: It is set only for the first bar of the following bar start times.
  optional sint64 bar_utc_time = 1;

  // Bar index.
  //
  // Note: Different bars with the same bar_utc_time always have different indexes.
  // Greater index means later bar.
  // It is set only if non-zero.
  optional sint32 index = 2;

  // Trade date (in time format).
  //
  // Note: It is set only for the first bar of the following trade dates.
  optional sint64 trade_date = 3;

  // Close price.
  optional sint64 scaled_close_price = 4;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 5 [deprecated = true];

  // Exchange volume.
  optional cqg.Decimal volume = 7;

  // Continuation segment the bar belongs to.
  //
  // Note: It is set only for the first bar and for each first bar from the next continuation segment.
  optional ContinuationSegment continuation_segment = 6;
}

// Historical data request for VolumeProfile.
//
// Prerequisites: client must have permission to volume profile data.
//
// Note: WebAPI rejects VolumeProfile requests with RESULT_CODE_FAILURE status code
// if they are sent less than 60 seconds after the previous request with the same parameters was completed.
//
// Limits:
//
// 1. The number of simultaneous historical requests in processing is 10 by default
//    (including all types of historical requests).
// 2. The number of simultaneous historical requests with a subscription for updates is 50 by default
//    (including all types of historical requests).
// 3. 3-month history limit.
//
// Responses: VolumeProfileReport.
message VolumeProfileRequest
{
  // Request ID.
  required uint32 request_id = 1;

  // Request parameters.
  optional VolumeProfileParameters volume_profile_parameters = 2;

  // Type of request action.
  enum RequestType
  {
    // Request data.
    REQUEST_TYPE_GET = 1;

    // Drop request before server completes it.
    REQUEST_TYPE_DROP = 3;
  }

  // Note: REQUEST_TYPE_GET operation is processed by default.
  //
  // Source: VolumeProfileRequest.RequestType.
  optional uint32 request_type = 3;
}

// Parameters of a Volume Profile request.
message VolumeProfileParameters
{
  // Contract ID for the volume profile request.
  //
  // Source: metadata_2.ContractMetadata.contract_id.
  required uint32 contract_id = 1;

  /// Both of the next two fields have to be set, otherwise the request will return a failure

  // Start of the time range for volume profile to be calculated for.
  //
  // Note: It is rounded down to a whole minute.
  optional sint64 start_utc_time = 2;

  // Exclusive end of the time range for volume profile to be calculated for.
  //
  // Note: It is rounded up to a whole minute.
  optional sint64 end_utc_time = 3;
}

// VolumeProfile snapshot response.
//
// Requests: VolumeProfileRequest.
message VolumeProfileReport
{
  // ID of the volume profile request.
  required uint32 request_id = 1;

  enum ResultCode
  {
    /// success codes  (0 - 99)

    // Request is processed successfully.
    RESULT_CODE_SUCCESS = 0;

    // The request is dropped by the client.
    RESULT_CODE_DROPPED = 2;

    // Request processing status that indicates that currently
    // processing is impossible because of communication issues.
    //
    // Note: Clients should not resend requests in this case,
    // the server will restore processing with sending RESULT_CODE_SUCCESS status
    // once communication issues are resolved. If client is not interested
    // in this request any longer it should send REQUEST_TYPE_DROP request.
    RESULT_CODE_DISCONNECTED = 4;

    /// failure codes (100+)

    // General failure.
    RESULT_CODE_FAILURE = 101;

    // The user is not allowed to access this instrument data.
    RESULT_CODE_ACCESS_DENIED = 103;

    // Requested information is not found.
    RESULT_CODE_NOT_FOUND = 104;

    // Requested data is outside of the allowed range.
    RESULT_CODE_OUTSIDE_ALLOWED_RANGE = 105;

    // The limit of the active historical requests has been violated.
    RESULT_CODE_ACTIVE_REQUESTS_LIMIT_VIOLATION = 106;

    // VolumeProfile request is not supported for specified contract.
    RESULT_CODE_NOT_SUPPORTED = 110;

    // Parameters of a VolumeProfile request are invalid.
    RESULT_CODE_INVALID_PARAMS = 111;
  }

  // Source: VolumeProfileReport.ResultCode.
  required uint32 result_code = 2;

  // Volume profile snapshot items.
  repeated VolumeProfileItem volume_profile_items = 3;

  // Volume profile cumulative statistics for the last quotes.
  //
  // Note: This field is filled only for the first chunk of the report.
  optional VolumeProfileLastQuotesCumulativeStatistics last_quotes_cumulative_statistics = 8;

  // Time up to which the quotes were included into this report.
  //
  // Note: If there were several with the same time-stamp equal to this time
  // then all are included into the report (UTC).
  // This time is set only for requests with unspecified 'end_utc_time' parameter
  // of message VolumeProfileParameters.
  optional int64 up_to_utc_time = 4;

  // Optional failure details.
  optional string text_message = 5 [deprecated = true];

  // Optional failure details.
  optional shared_1.Text details = 9;

  // Request contains dates partially outside of allowed historical data depth.
  optional bool truncated = 6;

  // Note: True means that requested data is complete at the moment,
  // false means more report messages are expected for completeness.
  optional bool is_report_complete = 7 [default = true];
}

// Volume profile cumulative statistics for the last quotes.
message VolumeProfileLastQuotesCumulativeStatistics
{
  // Price of the last best ask quote within Volume Profile range.
  optional sint64 scaled_last_ask_price = 1;

  // Price of the last best bid quote within Volume Profile range.
  optional sint64 scaled_last_bid_price = 2;

  // Note: Use ask_trade_volume instead.
  optional double scaled_ask_trade_volume = 3 [deprecated = true];

  // Cumulative sum of trade volumes on ask side since the last best bid or best ask price update
  // within Volume Profile range.
  optional double ask_trade_volume = 5;

  // Note: Use bid_trade_volume instead.
  optional double scaled_bid_trade_volume = 4 [deprecated = true];

  // Cumulative sum of trade volumes on bid side since the last best bid or best ask price update
  // within Volume Profile range.
  optional double bid_trade_volume = 6;
}

// Volume profile snapshot item.
message VolumeProfileItem
{
  // Price.
  //
  // Note: Unique for each volume profile snapshot reported.
  required sint64 scaled_price = 1;

  // Note: Use 'volume' instead.
  optional uint64 scaled_volume = 2 [deprecated = true];

  // Total volume of all trades with this price for the time range asked.
  //
  // Note: volume, ask_volume, bid_volume are omitted if volume is empty.
  // Trade volume is either associated with bid side or with ask side in the following manner:
  //
  //  1. If best bid and best ask are equal or crossed and the trade has happened,
  //     half of its volume is associated with the bid and half - with the ask.
  //  2. If the trade is less than or equal to best bid, all of its volume is associated with bid.
  //  3. If the trade is greater than or equal to best ask, all of its volume is associated with ask.
  //  4. If the trade is less than best ask and greater than best bid, its volume shall be split
  //     among bid and ask inversely proportional to the distances to best bid/best ask
  //     (closer trade to best bid, more qty associated with bid).
  optional cqg.Decimal volume = 3;

  // Ask part of total volume.
  optional cqg.Decimal ask_volume = 4;

  // Bid part of total volume.
  optional cqg.Decimal bid_volume = 5;

  // Total tick volume of all trades with this price for the time range asked.
  //
  // Note: tick_volume, ask_tick_volume, bid_tick_volume are omitted if tick_volume is 0.
  optional uint32 tick_volume = 6;

  // Ask part of tick volume.
  optional cqg.Decimal ask_tick_volume = 7;

  // Bid part of tick volume.
  optional cqg.Decimal bid_tick_volume = 8;
}
