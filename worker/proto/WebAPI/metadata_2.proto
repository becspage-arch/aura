// Public metadata related messages.

syntax = "proto2";

package metadata_2;

import "WebAPI/metadata_admin_2.proto";
import "WebAPI/strategy_definition_2.proto";
import "common/decimal.proto";
import "common/shared_1.proto";
import "google/protobuf/timestamp.proto";

// Request to resolve a symbol pattern or specific symbol identifier
// to a specific contract with optional subscription for metadata updates.
// Symbol resolution rules:
//
//   1. If the requested symbol points to a symbol prefix rather than a specific contract
//      then it is resolved into the most active contract for this symbol prefix (e.g., 'EP' is resolved to 'EPU3').
//      The update is sent when an active contract is changed (e.g., the update might contain the following 'EPZ3').
//   2. If the requested symbol points to an expired contract SymbolResolutionReport is returned with 'deleted' field
//      set to True.
//   3. If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself.
//      Update is sent only when metadata for such contract is changed or expired.
//      In case of expiration SymbolResolutionReport is returned with 'deleted' field set to True.
//   4. If requested symbol points to an option instrument without specific month and strike
//      it is resolved to the lead (first non-spot) month of the underlying future or its own front month
//      if the underlying contract is not a future (e.g., 'C.EP' is resolved to 'C.EPU131600').
//      Update is sent only when the resolved option contract is expired
//      (strike is not updated to follow underlying contract market price).
//   5. If requested symbol points to an option instrument without strike or with invalid strike
//      it is resolved to at-the-money strike for the specified month and year (except for expired options).
//   6. If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g., EP?2)
//      then it is resolved to Nth nearest contract.
//      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
//      '?' and '??' are different for futures only
//      and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
//      Update is sent when the front contract expired
//      and replaced with the following contract (relative position change).
//      N = 0 is a special case that means 'most active' contract which works the same way as (1.).
//      If requested symbol is a symbol prefix that follows '?(-N)' or '??(-N)' then it is resolved to Nth previous
//      contract.
//   7. If the requested short symbol is resolved to multiple instruments, the returned instrument will be chosen
//      based on supplied lists of preferred instrument types and preferred countries:
//
//      * If both lists are supplied, the type preference will be applied before the country preference;
//      * If only the type list is supplied, it will be applied before the default country preference;
//      * If only the country list is supplied, the default type preference will be applied before
//        the supplied country preference;
//      * If neither list is supplied, the default type and country preferences are applied.
//      For example, 'AMP' can be resolved to 'S.US.AMP' or 'S.AU.AMP' depending on preferred countries
//      having preferred instrument types 'S'.
//
// Note: Available and active contract lists are updated within 24 hours
//       of an expiring contract's final trading session.
//       Metadata updates for affected contracts, when a subscription is present, are sent when the list updates occur.
//       Initial resolution requests use the same lists, so the best way to avoid inconsistency
//       and unnecessary server load is to subscribe and process updates when notified.
//
// Limits: The request rate is 10000 per 24 hours by default.
//
// Response: SymbolResolutionReport.
message SymbolResolutionRequest
{
  // Symbol pattern to resolve.
  //
  // Required: yes.
  optional string symbol = 1;

  // Comma-separated list of preferred instrument types.
  // Type is encoded as a single character:
  //
  //  * F - Future
  //  * C - Call Option
  //  * P - Put Option
  //  * S - Equity
  //  * T - Bond
  //  * U - Strategy
  //  * X - Cash and others
  //
  // Example: 'F,C,P,X'.
  optional string preferred_types = 2;

  // Comma-separated list of preferred countries.
  // Two-letter ISO 3166-1 country codes or some CQG-specific exchange codes.
  // Example: 'US,AU'.
  optional string preferred_countries = 3;

  // Optional dialect ID to resolve the symbol in a dialect different from user_session_2.Logon.dialect_id.
  //
  // See: user_session_2.Logon.dialect_id.
  optional string resolution_dialect_id = 4;

  // Optional dialect ID indicating the preferred dialect for returned metadata.
  // If not set, SymbolResolutionRequest.resolution_dialect_id will be used.
  //
  // Note: There is no guarantee that the metadata will be returned in this dialect.
  // If it cannot be satisfied, the metadata will be returned without dialect-specific fields
  // (i.e., as in the default CQG dialect).
  optional string preferred_metadata_dialect_id = 5;

  // Reserved for internal use.
  extensions 100 to 199;
}

// Symbol resolution result or update.
//
// Request: SymbolResolutionRequest.
message SymbolResolutionReport
{
  // Resolved contract metadata.
  required ContractMetadata contract_metadata = 1;

  // Contract is expired (used for updates).
  optional bool deleted = 2;
}

// Request contract metadata by contract ID.
//
// Note: In case of subscription on metadata of synthetic strategy or deleted contract
//       WebAPI returns metadata without subscribing.
//
// Response: ContractMetadataReport.
message ContractMetadataRequest
{
  // Contract ID (ContractMetadata.contract_id) to request the metadata.
  //
  // Source: any contract id, not only from ContractMetadata.
  // E.g., ConversionMetadata.currency_rate_contract_id, order_2.Order.contract_id.
  required uint32 contract_id = 1;
}

// Report with the requested contract metadata.
//
// Request: ContractMetadataRequest.
message ContractMetadataReport
{
  // Requested metadata if successfully found.
  optional ContractMetadata contract_metadata = 1;
}

// Describes tick size and value, and the range of prices they apply to.
message TickSizeByPrice
{
  // Size of a single market tick in correct price format.
  required double tick_size = 1;

  // Contract tick money value in the contract's currency.
  // Zero if not applicable (e.g., for indexes).
  required double tick_value = 2;

  // Boundary of a half-open price range.
  // Minimum for positive values but maximum for negative values.
  //
  // - Negative value defines (prev-price <- boundary_price] range
  // - Positive value defines [boundary_price -> next-price) range
  // - Zero value defines (highest-negative-price <- 0] and [0 -> lowest-positive-price)
  //
  // The price is in correct price format.
  required double boundary_price = 3;
}

// Metadata used for real-time and trading data conversion.
message ConversionMetadata
{
  // Identifier of the currency contract (ContractMetadata.contract_id)
  // used for price conversion.
  optional uint32 currency_rate_contract_id = 1;

  // Identifier of the currency contract (ContractMetadata.contract_id)
  // used for hedging conversion.
  optional uint32 currency_hedge_contract_id = 2;
}

// Way how to track the trader's open positions on a given contract.
enum PositionTrackingType
{
  // Difference between long and short open positions is tracked.
  POSITION_TRACKING_TYPE_NET_POSITION = 1;

  // Long and short open positions are tracked separately.
  POSITION_TRACKING_TYPE_LONG_SHORT_WITH_IMPLIED_CLOSE = 2;

  // Long and short as well as today and yesterday open positions are tracked separately.
  // The explicit order instruction to close either today or yesterday is taken into account.
  POSITION_TRACKING_TYPE_LONG_SHORT_WITH_EXPLICIT_CLOSE = 3;
}

// Recommended display mode for prices.
// The rules are applied according to the display scale of a contract.
// For combined scales like Eighths of Thirty Seconds the mode is applied only to the minor fractions (Eighths) while
// the major fractions (Thirty Seconds) always shown in PRICE_DISPLAY_MODE_NUMERATOR mode.
//
// Sample: TRUNCATED mode for 108 22/32 with extra 7/8 of 1/32 (108 + 22/32 + 7/256)
// is shown as 108'228 where 8 is calculated as 7/8 -> truncate (0.875) -> 8 (see TRUNCATED sample below).
enum PriceDisplayMode
{
  // The numerator of the fractional part is shown directly.
  //
  // Samples: for 3/8 the fractional part is shown as '3', for 7/16 - '07', for 15/100 - '15' etc.
  PRICE_DISPLAY_MODE_NUMERATOR = 0;

  // Rounded decimal. In this mode the fractional part is converted to the decimal fraction
  // and then rounded half down to the minimum digits which are necessary to recognize the price.
  // Samples: 2/8 -> 0.25 -> '2', 3/8 -> 0.375 -> '4', 7/8 -> 0.875 -> '9', 14/16 -> 0.875 -> '87'.
  // It means the same as PRICE_DISPLAY_MODE_NUMERATOR for decimal scales.
  PRICE_DISPLAY_MODE_ROUNDED = 1;

  // Truncated decimal. In this mode the fractional part is converted to the decimal fraction
  // and then truncated to the minimum digits which are necessary to recognize the price.
  //
  // Samples: 3/8 -> truncate(0.375) -> '3', 7/8 -> truncate (0.875) -> '8', 11/16 -> truncate (0.6875) -> '68'.
  // It means the same as PRICE_DISPLAY_MODE_NUMERATOR for decimal scales.
  PRICE_DISPLAY_MODE_TRUNCATED = 2;
}

// Describes period value type.
// See example in ContractMetadata.listing_period_type and ContractMetadata.listing_period_value.
enum PeriodType
{
  PERIOD_TYPE_MONTH = 0;
  PERIOD_TYPE_QUARTER = 1;
  PERIOD_TYPE_SEMI_ANNUAL = 2;
  PERIOD_TYPE_YEAR = 3;
  PERIOD_TYPE_DAY_OF_WEEK = 4;
  PERIOD_TYPE_DAY_OF_MONTH = 5;
  PERIOD_TYPE_DAY_OF_YEAR = 6;
  PERIOD_TYPE_WEEK_OF_MONTH = 7;
  PERIOD_TYPE_WEEK_OF_YEAR = 8;
  PERIOD_TYPE_SECOND = 9;
  PERIOD_TYPE_MINUTE = 10;
  PERIOD_TYPE_HOUR = 11;
  PERIOD_TYPE_DATE = 12;
}

// CQG base instrument types eligible for user defined instrument requests.
enum CQGInstrumentType
{
  // Future or other instruments defined as a future in CQG, e.g., for some
  // exchanges, this includes forwards.
  CQG_INSTRUMENT_TYPE_FUTURE = 1;

  // Call option.
  CQG_INSTRUMENT_TYPE_CALL_OPTION = 2;

  // Put option.
  CQG_INSTRUMENT_TYPE_PUT_OPTION = 3;
}

// Settlement method.
enum SettlementMethod
{
  // Cash settled.
  SETTLEMENT_METHOD_CASH = 1;

  // Physically delivered.
  SETTLEMENT_METHOD_PHYSICAL = 2;
}

// Exercise style.
enum ExerciseStyle
{
  // European exercise style.
  EXERCISE_STYLE_EUROPEAN = 1;

  // American exercise style.
  EXERCISE_STYLE_AMERICAN = 2;
}

// Pricing convention aka return type.
enum PricingConvention
{
  // Price return.
  PRICING_CONVENTION_PRICE = 1;

  // Gross return.
  PRICING_CONVENTION_GROSS = 2;

  // Net return.
  PRICING_CONVENTION_NET = 3;
}

// Source of closing price.
enum CloseSource
{
  // Last quote except settlement.
  CLOSE_SOURCE_LAST_QUOTE = 1;

  // Settlement.
  CLOSE_SOURCE_SETTLEMENT = 2;

  // Exchange close.
  CLOSE_SOURCE_EXCHANGE_CLOSE = 3;
}

// Type of Order.open_close_instruction support for the contract.
enum OpenCloseType
{
  // Open/close instruction is not used.
  OPEN_CLOSE_TYPE_NOT_USED = 0;

  // Open/close instruction is not required but it may be used if provided.
  OPEN_CLOSE_TYPE_OPTIONAL = 1;

  // Open/close instruction is required.
  OPEN_CLOSE_TYPE_REQUIRED = 2;
}

// Contract metadata.
// Client must have a subscription on ContractMetadata updates if its fields are used (e.g., its correct_price_scale
// field when processing RealTimeMarketData). It can be done e.g., via ContractMetadataRequest.
message ContractMetadata
{
  // Server assigned ID for a contract, it is not the same across sessions.
  required uint32 contract_id = 1;

  // Full contract symbol in CQG dialect.
  optional string contract_symbol = 70;

  // Scale to convert prices from this protocol to correct prices
  // (correctPrice = price * correctPriceScale).
  required double correct_price_scale = 3;

  // Display Price Scale is a number that defines conversion of float correct price to
  // a 'native' integer display format and back.
  // Below is the table of possible scale values.
  //
  // | Scale |       Name             |   Description      |
  // |-------|------------------------|--------------------|
  // | 0     |One                     |Don't scale         |
  // | 1     |TenMinusOne             |Divide by 10        |
  // | 2     |TenMinusTwo             |Divide by 100       |
  // | 3     |TenMinusThree           |Divide by 1000      |
  // | 4     |TenMinusFour            |Divide by 10000     |
  // | 5     |TenMinusFive            |Divide by 100000    |
  // | 6     |TenMinusSix             |Divide by 1000000   |
  // | 7     |TenMinusSeven           |Divide by 10000000  |
  // | 8     |TenMinusEight           |Divide by 100000000 |
  // | 9     |TenMinusNine            |Divide by 1000000000|
  // | 10    |TenMinusTen             |Divide by 10^10     |
  // | 11    |TenMinusEleven          |Divide by 10^11     |
  // | 12    |TenMinusTwelve          |Divide by 10^12     |
  // | 13    |TenMinusThirteen        |Divide by 10^13     |
  // | 14    |TenMinusFourteen        |Divide by 10^14     |
  // | 15    |TenMinusFifteen         |Divide by 10^15     |
  // | 101   |Halves                  |Divide by 2         |
  // | 102   |Fourths                 |Divide by 4         |
  // | 103   |Eighths                 |Divide by 8         |
  // | 104   |Sixteenths              |Divide by 16        |
  // | 105   |ThirtySeconds           |Divide by 32        |
  // | 106   |SixtyFourths            |Divide by 64        |
  // | 107   |OneHundredTwentyEighths |Divide by 128       |
  // | 108   |TwoHundredFiftySixths   |Divide by 256       |
  // | 109   |FiveHundredTwelfths     |Divide by 512       |
  // | 110   |OneThousandTwentyFourths|Divide by 1024      |
  // | 201   |HalfThirtySeconds       |Similar to 64ths    |
  // | 202   |QuarterThirtySeconds    |Similar to 128ths   |
  // | 203   |EighthThirtySeconds     |Similar to 256ths   |
  // | 204   |HalfSixtyFourths        |Similar to 128ths   |
  // | 205   |QuarterSixtyFourths     |Similar to 256ths   |
  // | 206   |SixteenthThirtySeconds  |Similar to 512ths   |
  required uint32 display_price_scale = 4;

  // Contract description in CQG dialect.
  optional string description = 89;

  // Use description instead.
  optional string extended_description = 43 [deprecated = true];

  // Contract display name in CQG dialect.
  optional string title = 90;

  // Identifies the dialect applied to dialect_* fields.
  // If set to "0" (CQG dialect), dialect_* fields are not populated.
  optional string dialect_id = 28;

  // Full contract symbol in the dialect.
  //
  // Can be empty string. E.g., if ContractMetadata.dialect_id is "0" (which means default, CQG dialect)
  // or no available dialect metadata.
  // Use 'contract_symbol' in this case.
  required string dialect_contract_symbol = 2;

  // Contract description in the dialect.
  //
  // Can be empty string. E.g., if ContractMetadata.dialect_id is "0" (which means default, CQG dialect)
  // or no available dialect metadata.
  // Use 'description' in this case.
  required string dialect_description = 5;

  // Contract display name in the dialect.
  //
  // Can be empty string. E.g., if ContractMetadata.dialect_id is "0" (which means default, CQG dialect)
  // or no available dialect metadata.
  // Use 'title' in this case.
  required string dialect_title = 6;

  // Size of a single market tick in correct price format.
  required double tick_size = 7;

  // Contract currency code.
  // Empty string if not applicable (e.g., for indexes).
  required string currency = 8;

  // Contract tick money value in the contract's currency.
  // Zero if not applicable (e.g., for indexes).
  required double tick_value = 9;

  // CFI code (Classification of Financial Instruments, ISO 10962).
  required string cfi_code = 10;

  // True if this contract is the most active one for derivatives.
  optional bool is_most_active = 11;

  // Contract trading date for derivatives
  // (local exchange date in time format, use date part only).
  optional sint64 last_trading_date = 12;

  // Contract first notice date
  // (local exchange date in time format, use date part only).
  optional sint64 first_notice_date = 13;

  // Underlying contract symbol (e.g., for options and equities).
  optional string underlying_contract_symbol = 14;

  // Margin style (for options).
  enum MarginStyle
  {
    // The premium is paid on exercise/ expiry (position is included to OTE calculation).
    MARGIN_STYLE_FUTURE = 1;

    // Premium is subtracted from account balance when order is filled (position is included to MVO/UPL calculation).
    MARGIN_STYLE_PREMIUM = 2;
  }

  // This field is associated with MarginStyle enum type.
  optional uint32 margin_style = 15;

  // Name of a group of contracts that share the same properties (e.g., commodity name for futures and options).
  // The name is always provided in CQG dialect.
  required string instrument_group_name = 16;

  // Dialect name of a group of contracts that share the same properties (e.g. commodity name
  // for futures and options).
  // Note that this field can be empty even if ContractMetadata.dialect_id field is set.
  optional string dialect_instrument_group_name = 91;

  // ID of a session information this contract is related to.
  // The field is set to -1 if session information is not available.
  required sint32 session_info_id = 17;

  // Market segment MIC (ISO 10383) of the contract (if available), e.g., 'GLBX'.
  optional string mic = 18;

  // Market segment MIC description (ISO 10383) of the contract (if available), e.g., 'CME GLOBEX'.
  optional string mic_description = 44;

  // If a user has access to delayed data of the contract
  // then this parameter is set to the delay value in milliseconds.
  optional sint64 market_data_delay = 20;

  // If user is not allowed to receive quotes then End of Day (EOD) data for this contract can be allowed.
  // In case of real-time market data subscriptions only level LEVEL_END_OF_DAY is supported.
  // In case of time bar requests only Daily (or larger) bars are supported.
  //
  // Note: Data for current and previous trading days are available only if corresponding trading day
  // was closed |end_of_day_delay| milliseconds ago.
  optional sint64 end_of_day_delay = 59;

  // Instrument group name without the prefix.
  required string short_instrument_group_name = 21;

  // Description of the instrument group.
  required string instrument_group_description = 22;

  // Variable tick size by contract price (if available for the contract).
  // If variable tick sizes by contract price are available, tick_size and tick_value specify the minimal tick size
  // and value among these.
  repeated TickSizeByPrice tick_sizes_by_price = 23;

  // Option strike display value.
  optional sint32 strike = 26;

  // Option strike price value (directly in correct format).
  optional double strike_price = 27;

  // Scale which can be used for strike_price formatting.
  // See: display_price_scale comment for possible values.
  optional uint32 strike_price_scale = 86;

  // Two-letter exchange country code (ISO 3166-1 alpha 2).
  required string country_code = 29;

  // Strategy definition if the contract is of a synthetic or a user defined strategy.
  optional strategy_definition_2.StrategyDefinition strategy_definition = 30;

  // The deliverable quantity of commodities or financial instruments underlying contract.
  // E.g. "1,000 U.S. Barrels (42,000) Gallons", "125,000 Euro"
  optional string contract_size = 31;

  // Setting which regulates how to calculate contract open positions.
  // This field is associated with PositionTrackingType enum type.
  // POSITION_TRACKING_TYPE_NET_POSITION, if not set.
  optional uint32 position_tracking = 32;

  // Setting which requires whether every contract order has to specify SpeculationType instruction or not.
  optional bool speculation_type_required = 33 [default = false];

  // Month letter and 2-digit year identifying the maturity month of the contract (if applicable).
  // Doesn't depend on dialect.
  // Month and corresponding letter:
  //
  // * January   F
  // * February  G
  // * March     H
  // * April     J
  // * May       K
  // * June      M
  // * July      N
  // * August    Q
  // * September U
  // * October   V
  // * November  X
  // * December  Z
  optional string maturity_month_year = 34;

  // Contract's maturity date (e.g., for daily futures, when maturity_month_year is not enough).
  // (local exchange date in time format, use date part only).
  optional sint64 maturity_date = 53;

  // Recommended display mode for prices. See the PriceDisplayMode description.
  optional PriceDisplayMode price_display_mode = 35;

  // Currency code. For forex contracts only. Specifies the currency bought or sold.
  optional string foreign_currency = 39;

  // Specifies a volume unit of a contract, similar to correct_price_scale.
  // If a message contains a volume as uint64 (like Quote or TimeBar), its correct volume is calculated as:
  //   correct_volume = Quote.volume * volume_scale.
  // If a message contains a volume as cqg.Decimal, it is the correct volume.
  // If a contract has no fixed scale, this value is 1, and only cqg.Decimal volumes must be used.
  optional cqg.Decimal volume_scale = 40 [deprecated = true];

  // Specifies the recommended representation of volumes to users:
  //
  //  - negative numbers - '-N' - mean that N decimal digits should be shown.
  //  - positive numbers - 'N' - mean that N digits can be hidden behind a unit prefix (or unit symbol),
  //    e.g., if N = 3, volumes can be shown as "12k".
  optional sint32 volume_display_exponent = 41 [default = 0];

  // Trade volume is required to be a multiple of trade_size_increment.
  optional cqg.Decimal trade_size_increment = 42;

  // True if DOM views should be inverted: low numbers are at the top, high numbers are at the bottom.
  // This field is usually set for fixed income contracts with "prices are yields" model.
  optional bool has_inverted_price_ladder = 60;

  // The denominator (numerator is 1) of the DOM ladder compression ratio
  // to compress the ladder to eliminate all the extra/non-quoting values.
  optional uint32 dom_ladder_compression_ratio = 45;

  // Whether to expect that prices may appear not on the nominal tick prices
  // (not products of any tick_size: ordinal, variable, etc.) to changes DOM UI behavior.
  // Format such prices according to display_price_scale rule.
  optional bool expect_off_tick_prices = 46 [default = false];

  // Specifies whether exchange provides volume data or not.
  optional bool has_exchange_volume = 47 [default = true];

  // True if the contract supports yields and you can request them with MarketDataSubscription.include_yields.
  //
  // Note: If the contract has "prices are yields" model this field is false and yields are provided
  // through the price field.
  optional bool has_yields = 61;

  // The ISIN code acts an identifier for the securities.
  // And as such is the only common denominator securities identification number that is universally recognized.
  optional string isin = 48;

  // Reference value for initial margin, expressed as money value in the contract's currency.
  // Note the value is informational only, not updated real-time, and does not
  // consider the account's portfolio or risk settings/parameters.
  optional double initial_margin = 82;

  // Reference value for maintenance margin (required to maintain 1 lot position
  // in this contract), expressed as money value in the contract's currency.
  // Note the value is informational only, not updated real-time, and does not
  // consider the account's portfolio or risk settings/parameters.
  optional double maintenance_margin = 49;

  // Contract size in the number of units (where defined). Unit is defined by contract_size_unit filed.
  optional cqg.Decimal contract_size_in_units = 50;

  // Unit label for the contract size.
  optional shared_1.Text contract_size_unit = 51;

  // Contract last delivery date
  // (local exchange date in time format, use date part only).
  optional sint64 last_delivery_date = 52;

  // Optional custom contract parameters per associated OTC contributor (if any).
  repeated metadata_admin_2.ContributorParameters contributor_parameters = 54;

  // Type of listing period. This field is associated with PeriodType enum type.
  optional uint32 listing_period_type = 55;

  // Value of listing period in listing_period_type units.
  optional uint32 listing_period_value = 56;

  // ID of the symbol the contract represents (Symbol.id attribute).
  optional string symbol_id = 57;

  // If contract metadata is "deleted", corresponding contract id can't be referred to in requests anymore
  // (this happens e.g., when published contract gets unpublished).
  optional bool deleted = 58 [default = false];

  // ID used for ContributorMetadataRequest.
  optional sint32 contributor_group_id = 62;

  // If this instrument is double-quoted the field contains a contract id
  // to request corresponding source contract metadata
  // (see ContractMetadataRequest and ContractMetadata.contract_id).
  optional uint32 source_contract_id = 63;

  // Equity issuer.
  optional string issuer = 66;

  // Option contract's maturity ID.
  optional string option_maturity_id = 67;

  // Metadata used for real-time and trading data conversion.
  optional ConversionMetadata conversion_metadata = 68;

  // ID used for MarketStateMetadataRequest.
  optional sint32 market_state_group_id = 69;

  // Settlement method.
  // This field is associated with SettlementMethod enum type.
  optional uint32 settlement_method = 71;

  // Exercise style, for options only.
  // This field is associated with ExerciseStyle enum type.
  optional uint32 exercise_style = 72;

  // Pricing convention.
  // This field is associated with PricingConvention enum type.
  optional uint32 pricing_convention = 73;

  // True if contract represents user-defined instrument.
  optional bool is_user_defined_instrument = 74;

  // List of tick types used in bar building.
  // This field is associated with BarBuildingTickType enum type.
  //
  // Note: BAR_BUILDING_TICK_TYPE_SETTLEMENT is used only in time bars.
  //
  // Note: Not provided for Synthetic Strategies.
  repeated uint32 bar_building_tick_types = 75;

  // Describes what the contract is quoted in. E.g. "USD per Barrel", "Cents per Bushel"
  optional string quoted_in = 76;

  // Symbol ID (symbol_browsing_2.Symbol.id) of corresponding product if it was assigned to the contract.
  optional string product_symbol_id = 77;

  // Identifier of the contract (ContractMetadata.contract_id)
  // used for hedging, if applicable.
  // If not set, it is assumed to be the same as source contract.
  optional uint32 hedge_with_contract_id = 78;

  // If a contract is a synthetic version of real one,
  // this field contains a ContractMetadata.contract_id of real contract.
  optional uint32 actual_future_contract_id = 79;

  // Exchange ID this instrument belongs to.
  optional sint32 exchange_id = 80;

  // True if the contract supports continuation bars.
  optional bool supports_continuation = 81;

  // Instrument business type identifier.
  //
  // Note: This identifier is not guaranteed to be stable, so corresponding instrument
  // business type information should be obtained from results of SymbolCategoryListRequest
  // (see symbol_browsing_2.SymbolCategory.instrument_business_type_id field), instead of saving/using this id
  // between sessions to WebAPI.
  optional uint32 instrument_business_type_id = 83;

  // Sources of closing price.
  // Closing price can be found in message MarketValues and historical bars (message TimeBar and other).
  // Corresponding field name in related messages is scaled_close_price.
  // Order of sources defines what is used as closing price if several sources are available (from highest to
  // lowest priority).
  // This field is associated with CloseSource enum type.
  repeated uint32 close_sources = 84;

  // Open/close type.
  // This field is associated with OpenCloseType enum type.
  // OPEN_CLOSE_TYPE_NOT_USED if not set.
  optional uint32 open_close_type = 85;

  // True if this contract exists only within CQG systems, and doesn't exist on any exchange.
  // For example, it could be a synthetic strategy or a simulated exchange strategy.
  optional bool is_synthetic = 87;

  // Label temporarily attached to the instrument for display purposes.
  // Some exchanges have well-known strings with which they label various instruments - both simple and complex.
  optional string moniker = 88;

  // Reserved for internal use.
  extensions 300;

  reserved 24, 25, 36 to 38;
}

// Request for contributor metadata.
//
// Limits:
//
// 1. The request rate is 300 per 1 hour by default.
// 2. The number of simultaneous requests in processing is 300 by default.
// 3. The number of simultaneous update subscriptions is 300 by default.
//
// Response: ContributorMetadataReport.
message ContributorMetadataRequest
{
  // Contributor group ID from ContractMetadata.
  //
  // Source: ContractMetadata.contributor_group_id.
  optional sint32 contributor_group_id = 1;
}

// Report with contributor metadata.
//
// Request: ContributorMetadataRequest.
message ContributorMetadataReport
{
  // List of contributor metadata.
  //
  // Note: ContributorMetadata list may be empty even for valid ContributorMetadataRequest.contributor_group_id.
  repeated ContributorMetadata contributor_metadata = 1;
}

// Contributor metadata.
message ContributorMetadata
{
  // ID used in TradeAttributes as buyer and seller, DetailedDOMOrder as contributor_id.
  // Unique for its Contributor Group ID.
  optional sint32 contributor_id = 1;

  // Contributor name.
  optional string name = 2;

  // Contributor description.
  optional string description = 3;

  // Contributor is deleted (used for updates).
  optional bool deleted = 4;
}

// Request a list of option maturities by an underlying contract.
//
// Limits:
//
// 1. The number of simultaneous requests in processing is 5 by default.
// 2. The number of simultaneous update subscriptions is 100 by default.
//
// Response: OptionMaturityListReport.
message OptionMaturityListRequest
{
  required uint32 underlying_contract_id = 1;
}

// Report with a list of option maturities.
// When the list is updated by a subscription
// (e.g., some option maturity is expired or a new one appears)
// the list includes only new or deleted items.
//
// Request: OptionMaturityListRequest.
message OptionMaturityListReport
{
  // List of option maturities.
  repeated OptionMaturityMetadata option_maturities = 1;
}

// Option maturity metadata.
// It represents a list of option strikes (puts and calls) with the same underlying instrument and expiration date.
message OptionMaturityMetadata
{
  // Option maturity identifier.
  required string id = 1;

  // Option maturity name.
  required string name = 2;

  // Option maturity description.
  required string description = 3;

  // CFI code (Classification of Financial Instruments, ISO 10962) if appropriate.
  optional string cfi_code = 4;

  // Deleted flag is used in updates when the option maturity is removed (e.g., expired).
  optional bool deleted = 7;

  // Last trading date (local exchange date in time format, use date part only).
  optional sint64 last_trading_date = 8;

  // Last trading date and time.
  optional google.protobuf.Timestamp last_trading_date_time_utc_timestamp = 20;

  // Month letter and 2-digit year identifying the maturity month.
  //
  // Note: Look at comment for maturity_month_year from ContractMetadata for further info.
  optional string maturity_month_year = 9;

  // Name of a group of instruments that share the same properties (e.g., commodity name).
  optional string instrument_group_name = 10;

  // Whether the option maturity instrument group has option strikes.
  // It relates to InstrumentGroupRequest request.
  // Some option strikes can be related to option maturity, but they can be absent in the group.
  // E.g., option strikes range is changed and strikes out of the range don't appear in the group.
  optional bool instrument_group_empty = 17;

  // Listing period type. This field is associated with PeriodType enum type.
  optional uint32 listing_period_type = 18;

  // Listing period value in listing_period_type units.
  optional uint32 listing_period_value = 19;

  optional bool reserved1 = 5;

  reserved 6, 11 to 16;
}

// Request a group of instruments by an instrument group identifier.
//
// Note: Dialect support in list requests is limited.
// Behavior may differ from symbol resolution,
// and dialect-specific fields might be omitted depending on server-side configuration.
//
// Limits:
//
// 1. The number of simultaneous requests in processing is 5 by default.
// 2. The number of simultaneous update subscriptions is 100 by default.
//
// Response: InstrumentGroupReport.
message InstrumentGroupRequest
{
  // Identifier of instrument group. It can be one of:
  //
  // * Option maturity id to get a group of option strikes (see OptionMaturityMetadata.id)
  // * Instrument group's name to get a group of futures (e.g. 'F.US.EP', see
  //   ContractMetadata.instrument_group_name or SecurityMetadata.source_instrument_group_name)
  required string instrument_group_id = 1;
}

// Report with a group of instruments.
//
// Request: InstrumentGroupRequest.
message InstrumentGroupReport
{
  // Instruments.
  repeated InstrumentGroupItem instruments = 1;
}

// Instrument group item.
message InstrumentGroupItem
{
  // Instrument group item identifier.
  required string id = 1;

  // Instrument name. The value matches ContractMetadata.contract_symbol.
  required string name = 2;

  // Instrument description.
  required string description = 3;

  // CFI code (Classification of Financial Instruments, ISO 10962) if appropriate.
  optional string cfi_code = 4;

  // Contract metadata.
  optional ContractMetadata contract_metadata = 6;

  // Deleted flag is used in updates when the instrument is removed from the group (e.g., expired).
  optional bool deleted = 7;

  // Last trading date for derivatives if applicable.
  // (local exchange date in time format, use date part only).
  optional sint64 last_trading_date = 8;

  // Month letter and 2-digit year identifying the maturity month of the instrument.
  // Note: Look at comment for maturity_month_year from ContractMetadata for further info.
  optional string maturity_month_year = 9;

  // Name of a group of instruments that share the same properties (e.g., commodity name for futures and options).
  optional string instrument_group_name = 10;

  optional bool reserved1 = 5;
  optional string reserved2 = 11;

  reserved 12 to 16;
}

// Request for Market State metadata.
//
// Limits:
//
// 1. The request rate is 300 per 1 hour by default.
// 2. The number of simultaneous requests in processing is 300 by default.
// 3. The number of simultaneous update subscriptions is 300 by default.
//
// Response: MarketStateMetadataReport.
message MarketStateMetadataRequest
{
  // Market State Group ID from ContractMetadata.
  required sint32 market_state_group_id = 1;
}

// Market State metadata.
// The first complete report contains initial snapshot, which may be saved as local state.
// All subsequent messages contain updates that may be applied to the local state.
// Subscribed requests in case of server-side communication issues will receive
// an InformationReport with status_code "StatusCode.STATUS_CODE_DISCONNECTED".
// After issues resolution subscribed requests will receive an InformationReport
// with status_code "StatusCode.STATUS_CODE_SUBSCRIBED" and with a list of metadata updates, if there are any.
//
// Request: MarketStateMetadataRequest.
message MarketStateMetadataReport
{
  repeated MarketStateAttributeMetadata market_state_attribute_metadata = 1;
}

// Market State attribute metadata
//
// Note: To apply a metadata update one must follow rules:
//
// 1. If an update contains a MarketStateAttributeMetadata with a combination of "name" and
//    "level" fields values, which does not exist in the local state, then it must be added to it.
// 2. If an update contains a MarketStateAttributeMetadata with a combination of "name" and
//    "level" fields values, which already exists in the local state, then:
//    - If the field "deleted" is present and set to true - this Attribute should be deleted from the local state.
//    - Otherwise updates for value_metadata should be applied (see MarketStateValueMetadata comments).
message MarketStateAttributeMetadata
{
  // Attribute name
  optional string name = 1;

  // Attribute level in attributes hierarchy
  optional uint32 level = 2;

  // Attribute possible values metadata
  repeated MarketStateValueMetadata value_metadata = 3;

  // If present and true - attribute should be deleted from metadata
  optional bool deleted = 4;
}

// Market State attribute value metadata.
//
// Note: To apply a value metadata update one must follow rules:
//
// 1. If a received update has MarketStateValueMetadata with the "value" field value, which does not exist
//    in the local state, then this metadata must be added to it.
// 2. If a received update has MarketStateValueMetadata with the "value" field value, which exists
//    in the local state, then:
//    - If the field "deleted" present and set to true - this MarketStateValueMetadata should be deleted
//      from the local state.
//    - If the field "description" value is different from the value stored in the local state - it should be set
//      to the new value.
message MarketStateValueMetadata
{
  // Attribute value
  optional string value = 1;

  // Attribute value description
  optional string description = 2;

  // If present and true - attribute value metadata should be deleted
  optional bool deleted = 3;
}

// Request for exchange metadata.
//
// Limits: The number of subscriptions and simultaneous requests in processing is 1 per connection by default.
//
// Response: ExchangeMetadataReport.
message ExchangeMetadataRequest
{
}

// Report with exchange metadata.
//
// Request: ExchangeMetadataRequest.
message ExchangeMetadataReport
{
  // Requested exchange metadata.
  repeated ExchangeMetadata exchange_metadata = 1;
}

// Exchange metadata.
message ExchangeMetadata
{
  // Contributor type.
  enum ContributorType
  {
    CONTRIBUTOR_TYPE_UNDEFINED = 0;

    // Contributor is a quote source.
    CONTRIBUTOR_TYPE_US_EQUITY_STYLE = 1;

    // Contributor is a buyer.
    CONTRIBUTOR_TYPE_OTC_STYLE = 2;

    // Contributor is a seller.
    CONTRIBUTOR_TYPE_CLUSTER_STYLE = 3;
  }

  // Exchange ID.
  //
  // Required: yes.
  optional sint32 exchange_id = 1;

  // This field is associated with ContributorType enum type.
  optional uint32 contributor_type = 2;

  // Exchange abbreviation.
  optional string abbreviation = 3;

  // Exchange name.
  optional string name = 4;

  // Description.
  optional string description = 5;

  // If present and true - exchange metadata should be deleted.
  optional bool deleted = 6;
}

// Supported instrument group types.
enum InstrumentGroupType
{
  // Exchange strategies (a.k.a. User-defined strategies).
  INSTRUMENT_GROUP_TYPE_EXCHANGE_STRATEGY = 1;
}

// Request for a group of instruments based on a given list of securities.
// Multiple subscriptions on the same set of securities are prohibited.
//
// Note: Dialect support in list requests is limited.
// Behavior may differ from symbol resolution,
// and dialect-specific fields might be omitted depending on server-side configuration.
//
// Limits:
//
// 1. The request rate is 10000 per 24 hours by default.
// 2. The number of simultaneous requests in processing is 5 by default.
// 3. The number of simultaneous update subscriptions is 100 by default.
//
// Response: InstrumentGroupBySecuritiesReport.
message InstrumentGroupBySecuritiesRequest
{
  // IDs of the securities, can be from different exchanges.
  // Can be queried with ExchangeSecuritiesRequest.
  //
  // Source: SecurityMetadata.security_id.
  repeated string security_ids = 1;
}

// Report with a group of instruments.
//
// Request: InstrumentGroupBySecuritiesRequest.
message InstrumentGroupBySecuritiesReport
{
  // List of instruments.
  repeated InstrumentGroupItem instruments = 1;
}

// Request for a group of instruments based on a given exchange ID and type of instruments.
// Multiple subscriptions on the same exchange ID are prohibited.
//
// Note: Dialect support in list requests is limited.
// Behavior may differ from symbol resolution,
// and dialect-specific fields might be omitted depending on server-side configuration.
//
// Limits:
//
// 1. The request rate is 10000 per 24 hours by default.
// 2. The number of simultaneous requests in processing is 5 by default.
// 3. The number of simultaneous update subscriptions is 100 by default.
//
// Response: InstrumentGroupByExchangeReport.
message InstrumentGroupByExchangeRequest
{
  // Exchange ID.
  //
  // Required: yes.
  optional sint32 exchange_id = 1;

  // This field is associated with InstrumentGroupType enum type.
  //
  // Required: yes.
  optional uint32 instrument_group_type = 2;
}

// Report with a group of instruments.
//
// Request: InstrumentGroupByExchangeRequest.
message InstrumentGroupByExchangeReport
{
  // List of instruments.
  repeated InstrumentGroupItem instruments = 1;
}

// Request for a list of securities for a particular exchange and type of instruments.
//
// Limits:
//
// 1. The request rate is 300 per 1 hour by default.
// 2. The number of simultaneous requests in processing is 300 by default.
// 3. The number of simultaneous update subscriptions is 300 by default.
//
// Response: ExchangeSecuritiesReport.
message ExchangeSecuritiesRequest
{
  // Exchange ID.
  //
  // Source: ExchangeMetadata.exchange_id, ContractMetadata.exchange_id.
  //
  // Required: yes.
  optional sint32 exchange_id = 1;

  // This field is associated with InstrumentGroupType enum type.
  //
  // Required: yes.
  optional uint32 instrument_group_type = 2;
}

// Exchange securities report.
//
// Request: ExchangeSecuritiesRequest.
message ExchangeSecuritiesReport
{
  // List of securities.
  repeated SecurityMetadata exchange_securities = 1;
}

// Metadata used for real-time and trading data processing for a group of contracts.
// Note that for some contracts tick_size, tick_value or contract_size_in_units values on
// ContractMetadata level might differ from corresponding values in ProcessingMetadata
// (e.g., tick_size and tick_value for VTS contracts or contract_size_in_units for some option contracts).
// In these cases, ContractMetadata values should be used.
message ProcessingMetadata
{
  // Currency code.
  optional string currency = 1;

  // Size of a single market tick in correct price format.
  optional double tick_size = 2;

  // Tick money value in corresponding currency. See ProcessingMetadata.currency.
  optional double tick_value = 3;

  // Contract size in the number of units (where defined). Unit is defined by contract_size_unit field.
  optional cqg.Decimal contract_size_in_units = 4;

  // Unit label for the contract size.
  optional shared_1.Text contract_size_unit = 5;

  // Security whose contracts should be used to fill PublishContract.currency_rate_contract_id.
  // Use InstrumentGroupRequest to query contracts by group name.
  optional string currency_rate_instrument_group_name = 6;

  // Security whose contracts should be used to fill PublishContract.currency_hedge_contract_id.
  // Use InstrumentGroupRequest to query contracts by group name.
  optional string currency_hedge_instrument_group_name = 7;
}

// Security metadata.
message SecurityMetadata
{
  // Security ID.
  //
  // Required: yes.
  optional string security_id = 1;

  // Security name.
  //
  // Required: yes.
  optional string name = 14;

  // Security description.
  optional string description = 15;

  // CFI code (Classification of Financial Instruments, ISO 10962).
  optional string cfi_code = 2;

  // Deprecated and should not be used. Use ProcessingMetadata.currency instead.
  optional string currency = 3 [deprecated=true];

  // Deprecated and should not be used. Use ProcessingMetadata.tick_size instead.
  optional double tick_size = 4 [deprecated=true];

  // Deprecated and should not be used. Use ProcessingMetadata.tick_value instead.
  optional double tick_value = 5 [deprecated=true];

  // Deprecated and should not be used.
  optional uint32 period_type = 6 [deprecated=true];

  // Deprecated and should not be used.
  optional uint32 period_value = 7 [deprecated=true];

  // Deprecated and should not be used. Use ProcessingMetadata.contract_size_in_units instead.
  optional cqg.Decimal contract_size_in_units = 8 [deprecated=true];

  // Deprecated and should not be used. Use ProcessingMetadata.contract_size_unit instead.
  optional shared_1.Text contract_size_unit = 9 [deprecated=true];

  // Optional custom security parameters per associated OTC contributor (if any).
  repeated metadata_admin_2.ContributorParameters contributor_parameters = 10;

  // ID of the symbol the security represents (Symbol.id attribute).
  optional string symbol_id = 11;

  // If this security represents a list of double-quoted contracts, the field contains identifier
  // to request list of corresponding source instruments (see InstrumentGroupRequest).
  optional string source_instrument_group_name = 12;

  // Metadata used for real-time and trading data processing.
  // There might be different metadata properties for different contracts within the security.
  //
  // Note: This collection is empty when message received as a part of ExchangeSecuritiesReport.
  repeated ProcessingMetadata processing_metadata = 13;

  // Security is deleted (used for updates).
  optional bool deleted = 16;
}

// CQG country metadata.
// Can identify an actual country or exchange.
// Example: United States (US), WheatonGrains HMS (WT).
message CountryMetadata
{
  // Country ID.
  //
  // Required: yes.
  optional sint32 country_id = 1;

  // Country name.
  optional string name = 2;

  // Description of the country.
  optional string description = 3;

  // Abbreviation.
  optional string abbreviation = 4;

  // Two-letter country code (corresponds to ISO 3166-1 alpha 2 for an actual country).
  optional string country_code = 6;

  // Country is deleted (used for updates).
  optional bool deleted = 5;
}

// Request list of countries with metadata for them.
//
// Limits:
//
// 1. The request rate is 5 per 5 seconds by default.
// 2. The number of simultaneous requests in processing is 10 by default.
// 3. The number of simultaneous update subscriptions is 10 by default.
//
// Response: CountryListReport.
message CountryListRequest
{
}

// Report with a list of countries with metadata for them.
//
// Request: CountryListRequest.
message CountryListReport
{
  // List of countries with metadata for them
  repeated CountryMetadata countries = 1;
}

// Request message for retrieving metadata about a dialect.
// Subscription is not supported for this request.
//
// Expected response: DialectMetadataResult.
message DialectMetadataRequest
{
  // Identifier of the dialect for which metadata is requested.
  // Please contact CQG to get the list of supported dialects.
  //
  // Required: Yes.
  optional string dialect_id = 1;
}

// Response message containing metadata about the requested dialect.
//
// Corresponding request: DialectMetadataRequest.
message DialectMetadataResult
{
  // Identifier of the dialect.
  optional string dialect_id = 1;

  // Regular expression used to match contract names following the dialect-specific naming convention.
  //
  // Note: This pattern does not apply to synthetic or exchange strategy names.
  //
  // See: metadata_2.ContractMetadata.dialect_contract_symbol.
  optional string regular_expression = 2;
}
