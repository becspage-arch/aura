generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model UserProfile {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  email          String?           @unique
  displayName    String?
  clerkUserId    String?           @unique
  auditLogs      AuditLog[]
  brokerAccounts BrokerAccount[]
  userState      UserTradingState?
  onboardingNotificationsDone Boolean @default(false)
}

model BrokerAccount {
  id           String      @id @default(cuid())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  userId       String
  brokerName   String
  accountLabel String?
  externalId   String?
  user         UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  fills        Fill[]
  orders       Order[]

  @@unique([brokerName, externalId])
  @@index([userId])
  @@index([brokerName])
}

model Order {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brokerAccountId String
  externalId      String?
  symbol          String
  side            OrderSide
  type            OrderType
  status          OrderStatus   @default(NEW)
  qty             Decimal
  price           Decimal?
  stopPrice       Decimal?
  filledQty       Decimal       @default(0)
  avgFillPrice    Decimal?
  fills           Fill[]
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

model Fill {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  brokerAccountId String
  orderId         String?
  externalId      String?
  symbol          String
  side            OrderSide
  qty             Decimal
  price           Decimal
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)
  order           Order?        @relation(fields: [orderId], references: [id])

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

model Execution {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Who / where
  userId         String
  brokerName     String
  contractId     String
  symbol         String?

  // Deterministic idempotency key (unique)
  execKey        String   @unique

  // Intent
  side           OrderSide
  qty            Decimal
  entryType      String   // "market" | "limit" | "stop" (string so brokers can extend)
  stopLossTicks  Int?
  takeProfitTicks Int?
  customTag      String?

  // Broker linkage (for now ProjectX returns one orderId; future brokers may have separate ids)
  entryOrderId   String?
  stopOrderId    String?
  tpOrderId      String?

  status         ExecutionStatus @default(INTENT_CREATED)
  error          String?
  meta           Json?

  @@index([userId, createdAt])
  @@index([brokerName, createdAt])
  @@index([contractId, createdAt])
}

enum ExecutionStatus {
  INTENT_CREATED
  ORDER_SUBMITTED
  ORDER_ACCEPTED
  ORDER_FILLED
  BRACKET_SUBMITTED
  BRACKET_ACTIVE
  POSITION_OPEN
  POSITION_CLOSED
  FAILED
  CANCELLED
}

/**
 * -----------------------------
 * Canonical candle storage (BEST LONG-TERM)
 * -----------------------------
 * Store ONLY 15-second candles here.
 * - time = epoch seconds (UTC), candle OPEN time
 * - This makes charting + merging + marker mapping deterministic and fast.
 * - All higher timeframes (3m, 5m, etc.) are derived server-side.
 */
model Candle15s {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  symbol    String
  time      Int // epoch seconds (UTC), candle OPEN time

  open   Decimal
  high   Decimal
  low    Decimal
  close  Decimal
  volume Decimal?

  @@unique([symbol, time])
  @@index([symbol, time])
}

/**
 * -----------------------------
 * Normalized market quote storage (ProjectX + future brokers)
 * -----------------------------
 * One row per incoming L1 quote snapshot.
 * - broker: "projectx" / "cqg" / etc
 * - instrumentId: broker-specific contract id/key (e.g. "CON.F.US.MES.H26")
 * - symbol: your internal symbol label (e.g. "MES" or "MGC") if you have it; otherwise can mirror broker symbolId
 * - ts: the quote timestamp (from broker payload) if available
 * - receivedAt: when OUR worker received/processed the quote
 */
model MarketQuote {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  broker       String
  instrumentId String
  symbol       String?

  ts         DateTime?
  receivedAt DateTime @default(now())

  last Decimal?
  bid  Decimal?
  ask  Decimal?

  volume Decimal?
  raw    Json?

  @@index([broker, instrumentId, receivedAt])
  @@index([symbol, receivedAt])
  @@index([receivedAt])
}

/**
 * -----------------------------
 * Legacy candle table (keep for now)
 * -----------------------------
 * You already have this. We leave it in place so nothing breaks.
 * We'll gradually migrate reads/writes to Candle15s.
 */
model Candle {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  symbol    String
  timeframe CandleTimeframe
  ts        DateTime
  open      Decimal
  high      Decimal
  low       Decimal
  close     Decimal
  volume    Decimal?

  @@unique([symbol, timeframe, ts])
  @@index([symbol, timeframe, ts])
}

model EventLog {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  type            String
  level           String
  message         String
  data            Json?
  userId          String?
  brokerAccountId String?
  orderId         String?

  @@index([type, createdAt])
  @@index([level, createdAt])
}

model AuditLog {
  id        String      @id @default(cuid())
  createdAt DateTime    @default(now())
  userId    String
  action    String
  data      Json?
  user      UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
}

model NotificationLog {
  id        String   @id @default(cuid())
  userId    String
  key       String   @unique
  type      String
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model SystemState {
  id        String   @id @default(cuid())
  updatedAt DateTime @updatedAt
  key       String   @unique
  value     Json
}

model UserTradingState {
  id                      String   @id @default(cuid())
  updatedAt               DateTime @updatedAt
  userId                  String   @unique
  selectedBrokerAccountId String?
  selectedSymbol          String?
  riskSettings            Json?
  strategySettings Json?

  isPaused       Boolean   @default(false)
  isKillSwitched Boolean   @default(false)
  killSwitchedAt DateTime?

  user UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Trade {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())

  // Ownership
  clerkUserId   String

  // Idempotency (prevents duplicate rows on reconnects)
  execKey       String   @unique

  // Instrument
  symbol        String
  contractId    String?

  // Direction & size
  side          OrderSide
  qty           Decimal

  // Timing
  openedAt      DateTime
  closedAt      DateTime
  durationSec   Int?

  // Planned (from Execution intent)
  plannedStopTicks       Int?
  plannedTakeProfitTicks Int?
  plannedRiskUsd         Decimal?
  plannedRR              Decimal?

  // Actual fills
  entryPriceAvg  Decimal
  exitPriceAvg   Decimal
  realizedPnlTicks Int
  realizedPnlUsd   Decimal
  rrAchieved       Decimal?

  // Outcome / reason
  exitReason    String // "TP" | "SL" | "MANUAL" | "KILL_SWITCH" | "SESSION_END" | "FLATTEN" | "UNKNOWN"
  outcome       String // "WIN" | "LOSS" | "BREAKEVEN"

  @@index([clerkUserId, closedAt])
  @@index([clerkUserId, openedAt])
}

enum CandleTimeframe {
  S15
  M3
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
}

enum OrderStatus {
  NEW
  PLACED
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  REJECTED
}

model OneSignalPushSubscription {
  id             String   @id @default(cuid())
  userId         String
  subscriptionId String   @unique
  onesignalId    String?  @unique
  createdAt      DateTime @default(now())
  lastSeenAt     DateTime @updatedAt

  @@index([userId])
}
