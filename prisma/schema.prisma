generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model UserProfile {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  email          String?           @unique
  displayName    String?
  clerkUserId    String?           @unique
  auditLogs      AuditLog[]
  brokerAccounts BrokerAccount[]
  userState      UserTradingState?
}

model BrokerAccount {
  id           String      @id @default(cuid())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  userId       String
  brokerName   String
  accountLabel String?
  externalId   String?
  user         UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  fills        Fill[]
  orders       Order[]

  @@unique([brokerName, externalId])
  @@index([userId])
  @@index([brokerName])
}

model Order {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brokerAccountId String
  externalId      String?
  symbol          String
  side            OrderSide
  type            OrderType
  status          OrderStatus   @default(NEW)
  qty             Decimal
  price           Decimal?
  stopPrice       Decimal?
  filledQty       Decimal       @default(0)
  avgFillPrice    Decimal?
  fills           Fill[]
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

model Fill {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  brokerAccountId String
  orderId         String?
  externalId      String?
  symbol          String
  side            OrderSide
  qty             Decimal
  price           Decimal
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)
  order           Order?        @relation(fields: [orderId], references: [id])

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

/**
 * -----------------------------
 * Canonical candle storage (BEST LONG-TERM)
 * -----------------------------
 * Store ONLY 15-second candles here.
 * - time = epoch seconds (UTC), candle OPEN time
 * - This makes charting + merging + marker mapping deterministic and fast.
 * - All higher timeframes (3m, 5m, etc.) are derived server-side.
 */
model Candle15s {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  symbol    String
  time      Int // epoch seconds (UTC), candle OPEN time

  open   Decimal
  high   Decimal
  low    Decimal
  close  Decimal
  volume Decimal?

  @@unique([symbol, time])
  @@index([symbol, time])
}

/**
 * -----------------------------
 * Normalized market quote storage (ProjectX + future brokers)
 * -----------------------------
 * One row per incoming L1 quote snapshot.
 * - broker: "projectx" / "cqg" / etc
 * - instrumentId: broker-specific contract id/key (e.g. "CON.F.US.MES.H26")
 * - symbol: your internal symbol label (e.g. "MES" or "MGC") if you have it; otherwise can mirror broker symbolId
 * - ts: the quote timestamp (from broker payload) if available
 * - receivedAt: when OUR worker received/processed the quote
 */
model MarketQuote {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  broker       String
  instrumentId String
  symbol       String?

  ts         DateTime?
  receivedAt DateTime @default(now())

  last Decimal?
  bid  Decimal?
  ask  Decimal?

  volume Decimal?
  raw    Json?

  @@index([broker, instrumentId, receivedAt])
  @@index([symbol, receivedAt])
  @@index([receivedAt])
}

/**
 * -----------------------------
 * Legacy candle table (keep for now)
 * -----------------------------
 * You already have this. We leave it in place so nothing breaks.
 * We'll gradually migrate reads/writes to Candle15s.
 */
model Candle {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  symbol    String
  timeframe CandleTimeframe
  ts        DateTime
  open      Decimal
  high      Decimal
  low       Decimal
  close     Decimal
  volume    Decimal?

  @@unique([symbol, timeframe, ts])
  @@index([symbol, timeframe, ts])
}

model EventLog {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  type            String
  level           String
  message         String
  data            Json?
  userId          String?
  brokerAccountId String?
  orderId         String?

  @@index([type, createdAt])
  @@index([level, createdAt])
}

model AuditLog {
  id        String      @id @default(cuid())
  createdAt DateTime    @default(now())
  userId    String
  action    String
  data      Json?
  user      UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
}

model SystemState {
  id        String   @id @default(cuid())
  updatedAt DateTime @updatedAt
  key       String   @unique
  value     Json
}

model UserTradingState {
  id                      String   @id @default(cuid())
  updatedAt               DateTime @updatedAt
  userId                  String   @unique
  selectedBrokerAccountId String?
  selectedSymbol          String?
  riskSettings            Json?
  strategySettings Json?

  isPaused       Boolean   @default(false)
  isKillSwitched Boolean   @default(false)
  killSwitchedAt DateTime?

  user UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum CandleTimeframe {
  S15
  M3
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
}

enum OrderStatus {
  NEW
  PLACED
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  REJECTED
}
