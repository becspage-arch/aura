generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model UserProfile {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  email          String?           @unique
  displayName    String?
  clerkUserId    String?           @unique
  auditLogs      AuditLog[]
  brokerAccounts BrokerAccount[]
  userState      UserTradingState?
  onboardingNotificationsDone Boolean @default(false)
  notificationPrefs NotificationPreferences?
}

model BrokerAccount {
  id           String      @id @default(cuid())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  userId       String
  brokerName   String
  accountLabel String?
  externalId   String?

  user         UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Trading artifacts tied to this account
  fills        Fill[]
  orders       Order[]
  snapshots    AccountSnapshot[]

  // Desired run state (user intention)
  // - true  = Aura should run for this account (subject to pause/kill safety gates)
  // - false = Aura should not run for this account
  isEnabled    Boolean   @default(true)

  // Safety gates (temporary controls)
  isPaused       Boolean   @default(false)
  pausedAt       DateTime?
  isKillSwitched Boolean   @default(false)
  killSwitchedAt DateTime?

  // Per-account overrides (risk, symbols, strategy params etc)
  config         Json?

  // Worker health / orchestrator signals
  lastHeartbeatAt DateTime?

  @@unique([brokerName, externalId])
  @@index([userId])
  @@index([brokerName])
}

model AccountSnapshot {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())

  brokerAccountId String
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  // “Equity” = net liq / account value. Store what broker provides.
  equityUsd       Decimal?
  balanceUsd      Decimal?
  availableUsd    Decimal?
  unrealizedPnlUsd Decimal?
  marginUsedUsd   Decimal?

  // When the broker said this snapshot is “as of” (if provided). Fallback to now().
  ts              DateTime @default(now())

  raw             Json?

  @@index([brokerAccountId, ts])
  @@index([ts])
}

model Order {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brokerAccountId String
  externalId      String?
  symbol          String
  side            OrderSide
  type            OrderType
  status          OrderStatus   @default(NEW)
  qty             Decimal
  price           Decimal?
  stopPrice       Decimal?
  filledQty       Decimal       @default(0)
  avgFillPrice    Decimal?
  fills           Fill[]
  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

model Fill {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  brokerAccountId String
  orderId         String?
  externalId      String?
  symbol          String
  side            OrderSide
  qty             Decimal
  price           Decimal
  filledAt        DateTime?     // ✅ add this

  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)
  order           Order?        @relation(fields: [orderId], references: [id])

  @@unique([brokerAccountId, externalId])
  @@index([brokerAccountId, createdAt])
  @@index([symbol, createdAt])
}

model Execution {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Who / where
  userId         String
  brokerName     String
  contractId     String
  symbol         String?

  // Deterministic idempotency key (unique)
  execKey        String   @unique

  // Intent
  side           OrderSide
  qty            Decimal
  entryType      String   // "market" | "limit" | "stop" (string so brokers can extend)
  stopLossTicks  Int?
  takeProfitTicks Int?
  customTag      String?

  // Broker linkage (for now ProjectX returns one orderId; future brokers may have separate ids)
  entryOrderId   String?
  stopOrderId    String?
  tpOrderId      String?

  status         ExecutionStatus @default(INTENT_CREATED)
  error          String?
  meta           Json?

  @@index([userId, createdAt])
  @@index([brokerName, createdAt])
  @@index([contractId, createdAt])
}

enum ExecutionStatus {
  INTENT_CREATED
  ORDER_SUBMITTED
  ORDER_ACCEPTED
  ORDER_FILLED
  BRACKET_SUBMITTED
  BRACKET_ACTIVE
  POSITION_OPEN
  POSITION_CLOSED
  FAILED
  CANCELLED
}

/**
 * -----------------------------
 * Canonical candle storage (BEST LONG-TERM)
 * -----------------------------
 * Store ONLY 15-second candles here.
 * - time = epoch seconds (UTC), candle OPEN time
 * - This makes charting + merging + marker mapping deterministic and fast.
 * - All higher timeframes (3m, 5m, etc.) are derived server-side.
 */
model Candle15s {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  symbol    String
  time      Int // epoch seconds (UTC), candle OPEN time

  open   Decimal
  high   Decimal
  low    Decimal
  close  Decimal
  volume Decimal?

  @@unique([symbol, time])
  @@index([symbol, time])
}

model Candle3m {
  id        String   @id @default(cuid())

  symbol    String
  time      Int      // 3-minute candle open time (epoch seconds)

  open      Decimal
  high      Decimal
  low       Decimal
  close     Decimal

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([symbol, time], name: "symbol_time_3m")
  @@index([symbol, time])
}

/**
 * -----------------------------
 * Normalized market quote storage (ProjectX + future brokers)
 * -----------------------------
 * One row per incoming L1 quote snapshot.
 * - broker: "projectx" / "cqg" / etc
 * - instrumentId: broker-specific contract id/key (e.g. "CON.F.US.MES.H26")
 * - symbol: your internal symbol label (e.g. "MES" or "MGC") if you have it; otherwise can mirror broker symbolId
 * - ts: the quote timestamp (from broker payload) if available
 * - receivedAt: when OUR worker received/processed the quote
 */
model MarketQuote {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  broker       String
  instrumentId String
  symbol       String?

  ts         DateTime?
  receivedAt DateTime @default(now())

  last Decimal?
  bid  Decimal?
  ask  Decimal?

  volume Decimal?
  raw    Json?

  @@index([broker, instrumentId, receivedAt])
  @@index([symbol, receivedAt])
  @@index([receivedAt])
}

/**
 * -----------------------------
 * Legacy candle table (keep for now)
 * -----------------------------
 * You already have this. We leave it in place so nothing breaks.
 * We'll gradually migrate reads/writes to Candle15s.
 */
model Candle {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  symbol    String
  timeframe CandleTimeframe
  ts        DateTime
  open      Decimal
  high      Decimal
  low       Decimal
  close     Decimal
  volume    Decimal?

  @@unique([symbol, timeframe, ts])
  @@index([symbol, timeframe, ts])
}

model EventLog {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  type            String
  level           String
  message         String
  data            Json?
  userId          String?
  brokerAccountId String?
  orderId         String?

  @@index([type, createdAt])
  @@index([level, createdAt])
}

model AuditLog {
  id        String      @id @default(cuid())
  createdAt DateTime    @default(now())
  userId    String
  action    String
  data      Json?
  user      UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
}

model NotificationLog {
  id        String   @id @default(cuid())
  userId    String
  key       String   @unique
  type      String
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model SystemState {
  id        String   @id @default(cuid())
  updatedAt DateTime @updatedAt
  key       String   @unique
  value     Json
}

model UserTradingState {
  id                      String   @id @default(cuid())
  updatedAt               DateTime @updatedAt
  userId                  String   @unique
  selectedBrokerAccountId String?
  selectedSymbol          String?
  riskSettings            Json?
  strategySettings Json?

  isPaused       Boolean   @default(false)
  isKillSwitched Boolean   @default(false)
  killSwitchedAt DateTime?

  user UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Trade {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())

  // Ownership
  clerkUserId   String

  // Idempotency (prevents duplicate rows on reconnects)
  execKey       String   @unique

  // Instrument
  symbol        String
  contractId    String?

  // Direction & size
  side          OrderSide
  qty           Decimal

  // Timing
  openedAt      DateTime
  closedAt      DateTime
  durationSec   Int?

  // Planned (from Execution intent)
  plannedStopTicks       Int?
  plannedTakeProfitTicks Int?
  plannedRiskUsd         Decimal?
  plannedRR              Decimal?

  // Actual fills
  entryPriceAvg  Decimal
  exitPriceAvg   Decimal
  realizedPnlTicks Int
  realizedPnlUsd   Decimal
  rrAchieved       Decimal?

  // Outcome / reason
  exitReason    String // "TP" | "SL" | "MANUAL" | "KILL_SWITCH" | "SESSION_END" | "FLATTEN" | "UNKNOWN"
  outcome       String // "WIN" | "LOSS" | "BREAKEVEN"

  @@index([clerkUserId, closedAt])
  @@index([clerkUserId, openedAt])
}

enum CandleTimeframe {
  S15
  M3
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
}

enum OrderStatus {
  NEW
  PLACED
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  REJECTED
}

model StrategySignal {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Who / what
  userId    String
  strategy  String   // e.g. "coreplus315"
  brokerName String? // optional, but useful for later
  symbol    String
  contractId String?

  side      OrderSide

  // Times (epoch seconds)
  entryTime Int
  fvgTime   Int

  // Planned prices (optional but handy for chart overlays)
  entryPrice       Decimal?
  stopPrice        Decimal?
  takeProfitPrice  Decimal?

  // Risk math
  stopTicks   Decimal?
  tpTicks     Decimal?
  rr          Decimal?
  contracts   Int?
  riskUsdPlanned Decimal?

  // Outcome
  status      StrategySignalStatus @default(DETECTED)
  blockReason StrategyBlockReason?

  // Link to execution when TAKEN
  execKey     String?
  executionId String?

  // extra context (FVG top/bottom, retested, debug, bracket etc)
  meta        Json?

  // Deterministic idempotency key for “same signal”
  signalKey   String   @unique

  @@index([userId, createdAt])
  @@index([userId, strategy, createdAt])
  @@index([symbol, entryTime])
  @@index([executionId])
}

enum StrategySignalStatus {
  DETECTED
  BLOCKED
  TAKEN
}

enum StrategyBlockReason {
  IN_TRADE
  PAUSED
  KILL_SWITCH
  NOT_LIVE_CANDLE
  INVALID_BRACKET
  EXECUTION_FAILED

  // Engine / near-miss reasons (new)
  NO_ACTIVE_FVG
  FVG_INVALID
  FVG_ALREADY_TRADED
  NOT_RETESTED
  DIRECTION_MISMATCH
  NO_EXPANSION_PATTERN
  STOP_INVALID
  STOP_TOO_BIG
  CONTRACTS_ZERO
}

model NotificationPreferences {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String @unique
  user   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  // WHAT (event-level preferences)
  tradeClosedWins   Boolean @default(true)
  tradeClosedLosses Boolean @default(true)
  dailySummary      Boolean @default(false)
  strategyStatus    Boolean @default(true)

  // (Optional placeholders for later - we can add later if you prefer)
  // tradeOpened Boolean @default(false)
  // killSwitch  Boolean @default(true)

  @@index([userId])
}

model ApnsPushDevice {
  id          String   @id @default(cuid())
  userId      String
  deviceToken String   @unique
  environment String   // "sandbox" | "production"
  createdAt   DateTime @default(now())
  lastSeenAt  DateTime @updatedAt
  deviceName  String?

  @@index([userId])
  @@index([environment])
}

model OneSignalPushSubscription {
  id             String   @id @default(cuid())
  userId         String
  subscriptionId String   @unique
  onesignalId    String?  @unique
  createdAt      DateTime @default(now())
  lastSeenAt     DateTime @updatedAt

  @@index([userId])
}
